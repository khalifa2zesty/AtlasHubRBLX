-- made by: khalifa#6453
-- key "atlaswinning"

--$$$$$$\ $$$$$$$$\ $$\        $$$$$$\   $$$$$$\        $$\   $$\ $$\   $$\ $$$$$$$\  
--$$  __$$\\__$$  __|$$ |      $$  __$$\ $$  __$$\       $$ |  $$ |$$ |  $$ |$$  __$$\ 
--$$ /  $$ |  $$ |   $$ |      $$ /  $$ |$$ /  \__|      $$ |  $$ |$$ |  $$ |$$ |  $$ |
--$$$$$$$$ |  $$ |   $$ |      $$$$$$$$ |\$$$$$$\        $$$$$$$$ |$$ |  $$ |$$$$$$$\ |
--$$  __$$ |  $$ |   $$ |      $$  __$$ | \____$$\       $$  __$$ |$$ |  $$ |$$  __$$\ 
--$$ |  $$ |  $$ |   $$ |      $$ |  $$ |$$\   $$ |      $$ |  $$ |$$ |  $$ |$$ |  $$ |
--$$ |  $$ |  $$ |   $$$$$$$$\ $$ |  $$ |\$$$$$$  |      $$ |  $$ |\$$$$$$  |$$$$$$$  |
--\__|  \__|  \__|   \________|\__|  \__| \______/       \__|  \__| \______/ \_______/ 




local AtlasScriptHub = Instance.new("ScreenGui")
local MainFrameLogin = Instance.new("Frame")
local UICorner = Instance.new("UICorner")
local Background1 = Instance.new("ImageLabel")
local UICorner_2 = Instance.new("UICorner")
local UIGradient = Instance.new("UIGradient")
local Background2 = Instance.new("Frame")
local WelcomeText = Instance.new("TextLabel")
local TextLogin = Instance.new("TextBox")
local UICorner_3 = Instance.new("UICorner")
local UIGradient_2 = Instance.new("UIGradient")
local Submit = Instance.new("TextButton")
local UICorner_4 = Instance.new("UICorner")
local Credits = Instance.new("TextLabel")
local AtlasHub = Instance.new("Frame")
local UICorner_5 = Instance.new("UICorner")
local Frame = Instance.new("Frame")
local UICorner_6 = Instance.new("UICorner")
local Logo = Instance.new("TextLabel")
local ScriptList2 = Instance.new("ScrollingFrame")
local IY = Instance.new("TextButton")
local UICorner_7 = Instance.new("UICorner")
local AbilityWars = Instance.new("TextButton")
local UICorner_8 = Instance.new("UICorner")
local UniHub = Instance.new("TextButton")
local UICorner_9 = Instance.new("UICorner")
local BP = Instance.new("TextButton")
local UICorner_10 = Instance.new("UICorner")
local FNFAutoPlay = Instance.new("TextButton")
local UICorner_11 = Instance.new("UICorner")
local Frame_2 = Instance.new("Frame")
local Frame_3 = Instance.new("Frame")
local ImageLabel = Instance.new("ImageLabel")
local UICorner_12 = Instance.new("UICorner")
local TextLabel = Instance.new("TextLabel")
local Frame_4 = Instance.new("Frame")
local neko = Instance.new("TextButton")
local UICorner_13 = Instance.new("UICorner")
local reset = Instance.new("TextButton")
local UICorner_14 = Instance.new("UICorner")
local sam = Instance.new("TextButton")
local UICorner_15 = Instance.new("UICorner")
local TextLabel_2 = Instance.new("TextLabel")
local Frame_5 = Instance.new("Frame")
local UICorner_16 = Instance.new("UICorner")
local TextLabel_3 = Instance.new("TextLabel")
local UIListLayout = Instance.new("UIListLayout")



AtlasScriptHub.Name = "AtlasScriptHub"
AtlasScriptHub.Parent = game.CoreGui
AtlasScriptHub.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

MainFrameLogin.Name = "MainFrameLogin"
MainFrameLogin.Parent = AtlasScriptHub
MainFrameLogin.BackgroundColor3 = Color3.fromRGB(18, 18, 18)
MainFrameLogin.BorderColor3 = Color3.fromRGB(0, 0, 0)
MainFrameLogin.Position = UDim2.new(0.244791657, 0, 0.145859078, 0)
MainFrameLogin.Size = UDim2.new(0, 865, 0, 489)
MainFrameLogin.Active = true
MainFrameLogin.Draggable = true

UICorner.Parent = MainFrameLogin

Background1.Name = "Background1"
Background1.Parent = MainFrameLogin
Background1.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Background1.Size = UDim2.new(0, 458, 0, 489)
Background1.Image = "http://www.roblox.com/asset/?id=10393041195"

UICorner_2.Parent = Background1

UIGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 255, 255)), ColorSequenceKeypoint.new(0.80, Color3.fromRGB(147, 147, 147)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(18, 18, 18))}
UIGradient.Parent = Background1

Background2.Name = "Background2"
Background2.Parent = Background1
Background2.BackgroundColor3 = Color3.fromRGB(18, 18, 18)
Background2.BackgroundTransparency = 0.200
Background2.BorderSizePixel = 0
Background2.Position = UDim2.new(0.895196497, 0, 0, 0)
Background2.Size = UDim2.new(0, 48, 0, 489)

WelcomeText.Name = "WelcomeText"
WelcomeText.Parent = MainFrameLogin
WelcomeText.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
WelcomeText.BackgroundTransparency = 1.000
WelcomeText.BorderSizePixel = 0
WelcomeText.Position = UDim2.new(0.545664787, 0, 0.0736196339, 0)
WelcomeText.Size = UDim2.new(0, 369, 0, 103)
WelcomeText.Font = Enum.Font.Michroma
WelcomeText.Text = "Start today by loging in with the key!"
WelcomeText.TextColor3 = Color3.fromRGB(255, 255, 255)
WelcomeText.TextScaled = true
WelcomeText.TextSize = 63.000
WelcomeText.TextWrapped = true

TextLogin.Name = "TextLogin"
TextLogin.Parent = MainFrameLogin
TextLogin.BackgroundColor3 = Color3.fromRGB(27, 27, 27)
TextLogin.Position = UDim2.new(0.624277472, 0, 0.308793426, 0)
TextLogin.Size = UDim2.new(0, 232, 0, 59)
TextLogin.Font = Enum.Font.SourceSans
TextLogin.PlaceholderText = "Key goes here."
TextLogin.Text = ""
TextLogin.TextColor3 = Color3.fromRGB(0, 0, 0)
TextLogin.TextScaled = true
TextLogin.TextSize = 14.000
TextLogin.TextWrapped = true

UICorner_3.Parent = TextLogin

UIGradient_2.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(0, 0, 0)), ColorSequenceKeypoint.new(0.09, Color3.fromRGB(73, 73, 73)), ColorSequenceKeypoint.new(0.27, Color3.fromRGB(22, 22, 22)), ColorSequenceKeypoint.new(0.52, Color3.fromRGB(255, 255, 255)), ColorSequenceKeypoint.new(0.71, Color3.fromRGB(36, 36, 36)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(255, 255, 255))}
UIGradient_2.Parent = TextLogin

Submit.Name = "Submit"
Submit.Parent = MainFrameLogin
Submit.BackgroundColor3 = Color3.fromRGB(27, 27, 27)
Submit.BorderSizePixel = 0
Submit.Position = UDim2.new(0.623151541, 0, 0.483712107, 0)
Submit.Size = UDim2.new(0, 232, 0, 59)
Submit.Font = Enum.Font.SourceSans
Submit.Text = "Submit"
Submit.TextColor3 = Color3.fromRGB(255, 255, 255)
Submit.TextScaled = true
Submit.TextSize = 14.000
Submit.TextWrapped = true
Submit.MouseButton1Click:Connect(function()
	if TextLogin.Text == "atlaswinning" then
		MainFrameLogin.Visible = false
		wait(0.5)
		AtlasHub.Visible = true	
	end
end)

UICorner_4.Parent = Submit

Credits.Name = "Credits"
Credits.Parent = MainFrameLogin
Credits.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Credits.BackgroundTransparency = 1.000
Credits.BorderSizePixel = 0
Credits.Position = UDim2.new(0.642774582, 0, 0.860940754, 0)
Credits.Size = UDim2.new(0, 200, 0, 50)
Credits.Font = Enum.Font.SourceSans
Credits.Text = "All GUI is made by khalifa#6453"
Credits.TextColor3 = Color3.fromRGB(255, 255, 255)
Credits.TextSize = 14.000

AtlasHub.Name = "AtlasHub"
AtlasHub.Parent = AtlasScriptHub
AtlasHub.Active = true
AtlasHub.BackgroundColor3 = Color3.fromRGB(18, 18, 18)
AtlasHub.BorderColor3 = Color3.fromRGB(27, 42, 53)
AtlasHub.BorderSizePixel = 0
AtlasHub.Position = UDim2.new(0.274999946, 0, 0.19035846, 0)
AtlasHub.Size = UDim2.new(0, 749, 0, 412)
AtlasHub.Visible = false
AtlasHub.Draggable = true

UICorner_5.Parent = AtlasHub

Frame.Parent = AtlasHub
Frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Frame.BorderColor3 = Color3.fromRGB(27, 42, 53)
Frame.BorderSizePixel = 0
Frame.Size = UDim2.new(0, 749, 0, 35)

UICorner_6.Parent = Frame

Logo.Name = "Logo"
Logo.Parent = Frame
Logo.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Logo.BackgroundTransparency = 1.000
Logo.BorderSizePixel = 0
Logo.Position = UDim2.new(0.365821093, 0, 0, 0)
Logo.Size = UDim2.new(0, 200, 0, 35)
Logo.Font = Enum.Font.SourceSans
Logo.Text = "AtlasHubV1"
Logo.TextColor3 = Color3.fromRGB(255, 255, 255)
Logo.TextScaled = true
Logo.TextSize = 14.000
Logo.TextWrapped = true

ScriptList2.Name = "ScriptList2"
ScriptList2.Parent = AtlasHub
ScriptList2.Active = true
ScriptList2.BackgroundColor3 = Color3.fromRGB(27, 27, 27)
ScriptList2.BorderColor3 = Color3.fromRGB(0, 0, 0)
ScriptList2.Position = UDim2.new(0.575433969, 0, 0.106796116, 0)
ScriptList2.Size = UDim2.new(0, 311, 0, 359)

IY.Name = "IY"
IY.Parent = ScriptList2
IY.BackgroundColor3 = Color3.fromRGB(18, 18, 18)
IY.Position = UDim2.new(0.0482917354, 0, 0.405339777, 0)
IY.Size = UDim2.new(0, 277, 0, 50)
IY.Font = Enum.Font.Nunito
IY.Text = "Infinite Yield"
IY.TextColor3 = Color3.fromRGB(255, 255, 255)
IY.TextScaled = true
IY.TextSize = 14.000
IY.TextWrapped = true
IY.MouseButton1Down:connect(function()
	loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
end)

UICorner_7.Parent = IY

AbilityWars.Name = "AbilityWars"
AbilityWars.Parent = ScriptList2
AbilityWars.BackgroundColor3 = Color3.fromRGB(18, 18, 18)
AbilityWars.Position = UDim2.new(0.0563582219, 0, 0.213592246, 0)
AbilityWars.Size = UDim2.new(0, 277, 0, 50)
AbilityWars.Font = Enum.Font.Nunito
AbilityWars.Text = "Ability wars "
AbilityWars.TextColor3 = Color3.fromRGB(255, 255, 255)
AbilityWars.TextScaled = true
AbilityWars.TextSize = 14.000
AbilityWars.TextWrapped = true
AbilityWars.MouseButton1Down:connect(function()
	loadstring(game:HttpGet(('https://raw.githubusercontent.com/dizyhvh/rbx_scripts/main/dizzy_hub/scripts/ability_wars.lua')))();
end)

UICorner_8.Parent = AbilityWars

UniHub.Name = "UniHub"
UniHub.Parent = ScriptList2
UniHub.BackgroundColor3 = Color3.fromRGB(18, 18, 18)
UniHub.Position = UDim2.new(0.0563582219, 0, 0.117718436, 0)
UniHub.Size = UDim2.new(0, 277, 0, 50)
UniHub.Font = Enum.Font.Nunito
UniHub.Text = "Universal FE Hub"
UniHub.TextColor3 = Color3.fromRGB(255, 255, 255)
UniHub.TextScaled = true
UniHub.TextSize = 14.000
UniHub.TextWrapped = true
UniHub.MouseButton1Down:connect(function()
	loadstring(game:HttpGet('https://raw.githubusercontent.com/Dvrknvss/UniversalFEScriptHub/main/Script'))()
end)

UICorner_9.Parent = UniHub

BP.Name = "BP"
BP.Parent = ScriptList2
BP.BackgroundColor3 = Color3.fromRGB(18, 18, 18)
BP.Position = UDim2.new(0.0499273539, 0, 0.0242718458, 0)
BP.Size = UDim2.new(0, 277, 0, 50)
BP.Font = Enum.Font.Nunito
BP.Text = "Breaking Point"
BP.TextColor3 = Color3.fromRGB(255, 255, 255)
BP.TextScaled = true
BP.TextSize = 14.000
BP.TextWrapped = true
BP.MouseButton1Down:connect(function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/1iseo/breaking-point-public/main/main.lua"))()
end)

UICorner_10.Parent = BP

FNFAutoPlay.Name = "FNF AutoPlay"
FNFAutoPlay.Parent = ScriptList2
FNFAutoPlay.BackgroundColor3 = Color3.fromRGB(18, 18, 18)
FNFAutoPlay.Position = UDim2.new(0.0482917354, 0, 0.305825204, 0)
FNFAutoPlay.Size = UDim2.new(0, 277, 0, 50)
FNFAutoPlay.Font = Enum.Font.Nunito
FNFAutoPlay.Text = "Funky Friday"
FNFAutoPlay.TextColor3 = Color3.fromRGB(255, 255, 255)
FNFAutoPlay.TextScaled = true
FNFAutoPlay.TextSize = 14.000
FNFAutoPlay.TextWrapped = true
FNFAutoPlay.MouseButton1Down:connect(function()
	local start = tick()
	local client = game:GetService('Players').LocalPlayer;
	local set_identity = (type(syn) == 'table' and syn.set_thread_identity) or setidentity or setthreadcontext
	local executor = identifyexecutor and identifyexecutor() or 'Unknown'

	local function fail(r) return client:Kick(r) end

	-- gracefully handle errors when loading external scripts
	-- added a cache to make hot reloading a bit faster
	local usedCache = shared.__urlcache and next(shared.__urlcache) ~= nil

	shared.__urlcache = shared.__urlcache or {}
	local function urlLoad(url)
		local success, result

		if shared.__urlcache[url] then
			success, result = true, shared.__urlcache[url]
		else
			success, result = pcall(game.HttpGet, game, url)
		end

		if (not success) then
			return fail(string.format('Failed to GET url %q for reason: %q', url, tostring(result)))
		end

		local fn, err = loadstring(result)
		if (type(fn) ~= 'function') then
			return fail(string.format('Failed to loadstring url %q for reason: %q', url, tostring(err)))
		end

		local results = { pcall(fn) }
		if (not results[1]) then
			return fail(string.format('Failed to initialize url %q for reason: %q', url, tostring(results[2])))
		end

		shared.__urlcache[url] = result
		return unpack(results, 2)
	end

	-- attempt to block imcompatible exploits
	-- rewrote because old checks literally did not work
	if type(set_identity) ~= 'function' then return fail('Unsupported exploit (missing "set_thread_identity")') end
	if type(getconnections) ~= 'function' then return fail('Unsupported exploit (missing "getconnections")') end
	if type(getloadedmodules) ~= 'function' then return fail('Unsupported exploit (misssing "getloadedmodules")') end
	if type(getgc) ~= 'function' then   return fail('Unsupported exploit (misssing "getgc")') end

	local getinfo = debug.getinfo or getinfo;
	local getupvalue = debug.getupvalue or getupvalue;
	local getupvalues = debug.getupvalues or getupvalues;
	local setupvalue = debug.setupvalue or setupvalue;

	if type(setupvalue) ~= 'function' then return fail('Unsupported exploit (misssing "debug.setupvalue")') end
	if type(getupvalue) ~= 'function' then return fail('Unsupported exploit (misssing "debug.getupvalue")') end
	if type(getupvalues) ~= 'function' then return fail('Unsupported exploit (missing "debug.getupvalues")') end

	-- free exploit bandaid fix
	if type(getinfo) ~= 'function' then
		local debug_info = debug.info;
		if type(debug_info) ~= 'function' then
			-- if your exploit doesnt have getrenv you have no hope
			if type(getrenv) ~= 'function' then return fail('Unsupported exploit (missing "getrenv")') end
			debug_info = getrenv().debug.info
		end
		getinfo = function(f)
			assert(type(f) == 'function', string.format('Invalid argument #1 to debug.getinfo (expected %s got %s', 'function', type(f)))
			local results = { debug.info(f, 'slnfa') }
			local _, upvalues = pcall(getupvalues, f)
			if type(upvalues) ~= 'table' then
				upvalues = {}
			end
			local nups = 0
			for k in next, upvalues do
				nups = nups + 1
			end
			-- winning code
			return {
				source      = '@' .. results[1],
				short_src   = results[1],
				what        = results[1] == '[C]' and 'C' or 'Lua',
				currentline = results[2],
				name        = results[3],
				func        = results[4],
				numparams   = results[5],
				is_vararg   = results[6], -- 'a' argument returns 2 values :)
				nups        = nups,     
			}
		end
	end

	local UI = urlLoad("https://raw.githubusercontent.com/wally-rblx/LinoriaLib/main/Library.lua")
	local themeManager = urlLoad("https://raw.githubusercontent.com/wally-rblx/LinoriaLib/main/addons/ThemeManager.lua")

	local metadata = urlLoad("https://raw.githubusercontent.com/wally-rblx/funky-friday-autoplay/main/metadata.lua")
	local httpService = game:GetService('HttpService')

	local framework, scrollHandler, network
	local counter = 0

	while true do
		for _, obj in next, getgc(true) do
			if type(obj) == 'table' then 
				if rawget(obj, 'GameUI') then
					framework = obj;
				elseif type(rawget(obj, 'Server')) == 'table' then
					network = obj;     
				end
			end

			if network and framework then break end
		end

		for _, module in next, getloadedmodules() do
			if module.Name == 'ScrollHandler' then
				scrollHandler = module;
				break;
			end
		end 

		if (type(framework) == 'table' and typeof(scrollHandler) == 'Instance' and type(network) == 'table') then
			break
		end

		counter = counter + 1
		if counter > 6 then
			fail(string.format('Failed to load game dependencies. Details: %s, %s, %s', type(framework), typeof(scrollHandler), type(network)))
		end
		wait(1)
	end

	local runService = game:GetService('RunService')
	local userInputService = game:GetService('UserInputService')
	local virtualInputManager = game:GetService('VirtualInputManager')

	local random = Random.new()

	local task = task or getrenv().task;
	local fastWait, fastSpawn = task.wait, task.spawn;

	-- firesignal implementation
	-- hitchance rolling
	local fireSignal, rollChance do
		-- updated for script-ware or whatever
		-- attempted to update for krnl

		function fireSignal(target, signal, ...)
			-- getconnections with InputBegan / InputEnded does not work without setting Synapse to the game's context level
			set_identity(2)
			local didFire = false
			for _, signal in next, getconnections(signal) do
				if type(signal.Function) == 'function' and islclosure(signal.Function) then
					local scr = rawget(getfenv(signal.Function), 'script')
					if scr == target then
						didFire = true
						pcall(signal.Function, ...)
					end
				end
			end
			-- if not didFire then fail"couldnt fire input signal" end
			set_identity(7)
		end

		-- uses a weighted random system
		-- its a bit scuffed rn but it works good enough

		function rollChance()
			-- if (//library.flags.autoPlayerMode == 'Manual') then
			if Options.AutoplayerMode.Value == 'Manual' then
				if (Options.SickBind:GetState()) then return 'Sick' end
				if (Options.GoodBind:GetState()) then return 'Good' end
				if (Options.OkayBind:GetState()) then return 'Ok' end
				if (Options.BadBind:GetState()) then return 'Bad' end

				return 'Bad' -- incase if it cant find one
			end

			local chances = {
				{ 'Sick', Options.SickChance.Value },
				{ 'Good', Options.GoodChance.Value },
				{ 'Ok', Options.OkChance.Value },
				{ 'Bad', Options.BadChance.Value },
				{ 'Miss' , Options.MissChance.Value },
			}

			table.sort(chances, function(a, b)
				return a[2] > b[2]
			end)

			local sum = 0;
			for i = 1, #chances do
				sum += chances[i][2]
			end

			if sum == 0 then
				return chances[random:NextInteger(1, #chances)][1]
			end

			local initialWeight = random:NextInteger(0, sum)
			local weight = 0;

			for i = 1, #chances do
				weight = weight + chances[i][2]

				if weight > initialWeight then
					return chances[i][1]
				end
			end

			return 'Sick'
		end
	end

	-- autoplayer
	local chanceValues do
		chanceValues = { 
			Sick = 96,
			Good = 92,
			Ok = 87,
			Bad = 75,
		}

		local keyCodeMap = {}
		for _, enum in next, Enum.KeyCode:GetEnumItems() do
			keyCodeMap[enum.Value] = enum
		end

		if shared._unload then
			pcall(shared._unload)
		end

		function shared._unload()
			if shared._id then
				pcall(runService.UnbindFromRenderStep, runService, shared._id)
			end

			UI:Unload()

			for i = 1, #shared.threads do
				coroutine.close(shared.threads[i])
			end

			for i = 1, #shared.callbacks do
				task.spawn(shared.callbacks[i])
			end
		end

		shared.threads = {}
		shared.callbacks = {}

		shared._id = httpService:GenerateGUID(false)

		local rng = Random.new()
		runService:BindToRenderStep(shared._id, 1, function()
			--if (not library.flags.autoPlayer) then return end

			if (not Toggles.Autoplayer) or (not Toggles.Autoplayer.Value) then 
				return 
			end

			local currentlyPlaying = framework.SongPlayer.CurrentlyPlaying

			if typeof(currentlyPlaying) ~= 'Instance' or not currentlyPlaying:IsA('Sound') then 
				return 
			end

			local arrows = framework.UI:GetNotes()
			local count = framework.SongPlayer:GetKeyCount()
			local mode = count .. 'Key'

			local arrowData = framework.ArrowData[mode].Arrows
			for i, arrow in next, arrows do
				-- todo: switch to this (https://i.imgur.com/pEVe6Tx.png)
				local ignoredNoteTypes = { Death = true, Mechanic = true, Poison = true }

				if type(arrow.NoteDataConfigs) == 'table' then 
					if ignoredNoteTypes[arrow.NoteDataConfigs.Type] then 
						continue
					end
				end

				if (arrow.Side == framework.UI.CurrentSide) and (not arrow.Marked) and currentlyPlaying.TimePosition > 0 then
					local position = (arrow.Data.Position % count) .. '' 

					local hitboxOffset = 0 do
						local settings = framework.Settings;
						local offset = type(settings) == 'table' and settings.HitboxOffset;
						local value = type(offset) == 'table' and offset.Value;

						if type(value) == 'number' then
							hitboxOffset = value;
						end

						hitboxOffset = hitboxOffset / 1000
					end

					local songTime = framework.SongPlayer.CurrentTime do
						local configs = framework.SongPlayer.CurrentSongConfigs
						local playbackSpeed = type(configs) == 'table' and configs.PlaybackSpeed

						if type(playbackSpeed) ~= 'number' then
							playbackSpeed = 1
						end

						songTime = songTime /  playbackSpeed
					end

					local noteTime = math.clamp((1 - math.abs(arrow.Data.Time - (songTime + hitboxOffset))) * 100, 0, 100)

					local result = rollChance()
					arrow._hitChance = arrow._hitChance or result;

					local hitChance = (Options.AutoplayerMode.Value == 'Manual' and result or arrow._hitChance)
					if hitChance ~= "Miss" and noteTime >= chanceValues[arrow._hitChance] then
						fastSpawn(function()
							arrow.Marked = true;
							local keyCode = keyCodeMap[arrowData[position].Keybinds.Keyboard[1]]

							if Options.PressMode.Value == 'Key press' then
								virtualInputManager:SendKeyEvent(true, keyCode, false, nil)
							else
								fireSignal(scrollHandler, userInputService.InputBegan, { KeyCode = keyCode, UserInputType = Enum.UserInputType.Keyboard }, false)
							end

							local arrowLength = arrow.Data.Length or 0
							local isHeld = arrowLength > 0

							local delayMode = Options.DelayMode.Value

							local minDelay = isHeld and Options.HeldDelayMin or Options.NoteDelayMin;
							local maxDelay = isHeld and Options.HeldDelayMax or Options.NoteDelayMax;
							local noteDelay = isHeld and Options.HeldDelay or Options.ReleaseDelay

							if Options.DelayMode.Value == 'Random' then
								task.wait(arrowLength + rng:NextNumber(minDelay.Value, maxDelay.Value) / 1000)
							else
								task.wait(arrowLength + (noteDelay.Value / 1000))
							end

							if Options.PressMode.Value == 'Key press' then
								virtualInputManager:SendKeyEvent(false, keyCode, false, nil)
							else
								fireSignal(scrollHandler, userInputService.InputEnded, { KeyCode = keyCode, UserInputType = Enum.UserInputType.Keyboard }, false)
							end

							arrow.Marked = nil;
						end)
					end
				end
			end
		end)
	end

	local ActivateUnlockables do
		-- Note: I know you can do this with UserId but it only works if you run it before opening the notes menu
		-- My script should work no matter the order of which you run things :)

		local loadStyle = nil
		local function loadStyleProxy(...)
			-- This forces the styles to reload every time

			local upvalues = getupvalues(loadStyle)
			for i, upvalue in next, upvalues do
				if type(upvalue) == 'table' and rawget(upvalue, 'Style') then
					rawset(upvalue, 'Style', nil);
					setupvalue(loadStyle, i, upvalue)
				end
			end

			return loadStyle(...)
		end

		local function applyLoadStyleProxy(...)
			local gc = getgc()
			for i = 1, #gc do
				local obj = gc[i]
				if type(obj) == 'function' then
					-- goodbye nups numeric loop because script-ware is weird
					local upvalues = getupvalues(obj)
					for i, upv in next, upvalues do
						if type(upv) == 'function' and getinfo(upv).name == 'LoadStyle' then
							-- ugly but it works, we don't know every name for is_synapse_function and similar
							if getinfo(obj).source:match('%.ArrowSelector%.Customize$') and getinfo(upv).source:match('%.ArrowSelector%.Customize$') then
								-- avoid non-game functions :)

								loadStyle = loadStyle or upv
								setupvalue(obj, i, loadStyleProxy)

								table.insert(shared.callbacks, function()
									assert(pcall(setupvalue, obj, i, loadStyle))
								end)
							end
						end
					end
				end
			end
		end

		local success, error = pcall(applyLoadStyleProxy)
		if not success then
			return fail(string.format('Failed to hook LoadStyle function. Error(%q)\nExecutor(%q)\n', error, executor))
		end

		function ActivateUnlockables()
			local idx = table.find(framework.SongsWhitelist, client.UserId)
			if idx then return end

			UI:Notify('Developer arrows have been unlocked!', 3)
			table.insert(framework.SongsWhitelist, client.UserId)
		end
	end

	-- UpdateScore hook
	do
		local roundManager = nil;
		repeat
			task.wait()
			roundManager = network.Server.RoundManager
		until roundManager;
		local oldUpdateScore = type(roundManager) == 'table' and roundManager.UpdateScore;

		function roundManager.UpdateScore(...)
			local args = { ... }
			local score = args[2]

			if type(score) == 'number' and Options.ScoreModifier then
				if Options.ScoreModifier.Value == 'No decrease on miss' then
					args[2] = 0
				elseif Options.ScoreModifier.Value == 'Increase score on miss' then
					args[2] = math.abs(score)
				end
			end

			return oldUpdateScore(unpack(args))
		end

		table.insert(shared.callbacks, function()
			roundManager.UpdateScore = oldUpdateScore
		end)
	end

	local SaveManager = {} do
		SaveManager.Ignore = {}
		SaveManager.Parser = {
			Toggle = {
				Save = function(idx, object) 
					return { type = 'Toggle', idx = idx, value = object.Value } 
				end,
				Load = function(idx, data)
					if Toggles[idx] then 
						Toggles[idx]:SetValue(data.value)
					end
				end,
			},
			Slider = {
				Save = function(idx, object)
					return { type = 'Slider', idx = idx, value = tostring(object.Value) }
				end,
				Load = function(idx, data)
					if Options[idx] then 
						Options[idx]:SetValue(data.value)
					end
				end,
			},
			Dropdown = {
				Save = function(idx, object)
					return { type = 'Dropdown', idx = idx, value = object.Value, mutli = object.Multi }
				end,
				Load = function(idx, data)
					if Options[idx] then 
						Options[idx]:SetValue(data.value)
					end
				end,
			},
			ColorPicker = {
				Save = function(idx, object)
					return { type = 'ColorPicker', idx = idx, value = object.Value:ToHex() }
				end,
				Load = function(idx, data)
					if Options[idx] then 
						Options[idx]:SetValueRGB(Color3.fromHex(data.value))
					end
				end,
			},
			KeyPicker = {
				Save = function(idx, object)
					return { type = 'KeyPicker', idx = idx, mode = object.Mode, key = object.Value }
				end,
				Load = function(idx, data)
					if Options[idx] then 
						Options[idx]:SetValue({ data.key, data.mode })
					end
				end,
			}
		}

		function SaveManager:Save(name)
			local fullPath = 'funky_friday_autoplayer/configs/' .. name .. '.json'

			local data = {
				version = 2,
				objects = {}
			}

			for idx, toggle in next, Toggles do
				if self.Ignore[idx] then continue end
				table.insert(data.objects, self.Parser[toggle.Type].Save(idx, toggle))
			end

			for idx, option in next, Options do
				if not self.Parser[option.Type] then continue end
				if self.Ignore[idx] then continue end

				table.insert(data.objects, self.Parser[option.Type].Save(idx, option))
			end 

			local success, encoded = pcall(httpService.JSONEncode, httpService, data)
			if not success then
				return false, 'failed to encode data'
			end

			writefile(fullPath, encoded)
			return true
		end

		function SaveManager:Load(name)
			local file = 'funky_friday_autoplayer/configs/' .. name .. '.json'
			if not isfile(file) then return false, 'invalid file' end

			local success, decoded = pcall(httpService.JSONDecode, httpService, readfile(file))
			if not success then return false, 'decode error' end
			if decoded.version ~= 2 then return false, 'invalid version' end

			for _, option in next, decoded.objects do
				if self.Parser[option.type] then
					self.Parser[option.type].Load(option.idx, option)
				end
			end

			return true
		end

		function SaveManager.Refresh()
			local list = listfiles('funky_friday_autoplayer/configs')

			local out = {}
			for i = 1, #list do
				local file = list[i]
				if file:sub(-5) == '.json' then
					-- i hate this but it has to be done ...

					local pos = file:find('.json', 1, true)
					local start = pos

					local char = file:sub(pos, pos)
					while char ~= '/' and char ~= '\\' and char ~= '' do
						pos = pos - 1
						char = file:sub(pos, pos)
					end

					if char == '/' or char == '\\' then
						table.insert(out, file:sub(pos + 1, start - 1))
					end
				end
			end

			Options.ConfigList.Values = out;
			Options.ConfigList:SetValues()
			Options.ConfigList:Display()

			return out
		end

		function SaveManager:Delete(name)
			local file = 'funky_friday_autoplayer/configs/' .. name .. '.json'
			if not isfile(file) then return false, string.format('Config %q does not exist', name) end

			local succ, err = pcall(delfile, file)
			if not succ then
				return false, string.format('error occured during file deletion: %s', err)
			end

			return true
		end

		function SaveManager:SetIgnoreIndexes(list)
			for i = 1, #list do 
				table.insert(self.Ignore, list[i])
			end
		end

		function SaveManager.Check()
			local list = listfiles('funky_friday_autoplayer/configs')

			for _, file in next, list do
				if isfolder(file) then continue end

				local data = readfile(file)
				local success, decoded = pcall(httpService.JSONDecode, httpService, data)

				if success and type(decoded) == 'table' and decoded.version ~= 2 then
					pcall(delfile, file)
				end
			end
		end
	end

	local Window = UI:CreateWindow({
		Title = string.format('funky friday autoplayer - version %s | updated: %s', metadata.version, metadata.updated),
		AutoShow = true,

		Center = true,
		Size = UDim2.fromOffset(550, 627),
	})

	local Tabs = {}
	local Groups = {}

	Tabs.Main = Window:AddTab('Main')
	Tabs.Miscellaneous = Window:AddTab('Miscellaneous')

	Groups.Autoplayer = Tabs.Main:AddLeftGroupbox('Autoplayer')
	Groups.Autoplayer:AddToggle('Autoplayer', { Text = 'Autoplayer' }):AddKeyPicker('AutoplayerBind', { Default = 'End', NoUI = true, SyncToggleState = true })
	Groups.Autoplayer:AddDropdown('PressMode', { Text = 'Key press mode', Default = 'Fire signal', Values = { 'Fire signal', 'Key press' }, Tooltip = 'Set this to "Key press" if the other mode does not work' })

	Groups.Autoplayer:AddDivider()
	Groups.Autoplayer:AddDropdown('AutoplayerMode', { Text = 'Autoplayer mode', Default = 1, Values = { 'Chances', 'Manual' } })
	Groups.Autoplayer:AddDropdown('DelayMode', { Text = 'Delay mode', Default = 1, Values = { 'Manual', 'Random' } })

	Groups.Autoplayer:AddDivider()
	Groups.Autoplayer:AddDropdown('ScoreModifier', { 
		Text = 'Score modifications', 
		Default = 1, 
		Values = { 'Do nothing', 'No decrease on miss', 'Increase score on miss' },
		Tooltip = 'Modifies certain game functions to help you keep your score up!',
	})

	Groups.HitChances = Tabs.Main:AddLeftGroupbox('Hit chances')
	Groups.HitChances:AddSlider('SickChance',   { Text = 'Sick chance', Min = 0, Max = 100, Default = 100, Suffix = '%', Rounding = 0 })
	Groups.HitChances:AddSlider('GoodChance',   { Text = 'Good chance', Min = 0, Max = 100, Default = 0, Suffix = '%', Rounding = 0 })
	Groups.HitChances:AddSlider('OkChance',     { Text = 'Ok chance',   Min = 0, Max = 100, Default = 0, Suffix = '%', Rounding = 0 })
	Groups.HitChances:AddSlider('BadChance',    { Text = 'Bad chance',  Min = 0, Max = 100, Default = 0, Suffix = '%', Rounding = 0 })
	Groups.HitChances:AddSlider('MissChance',   { Text = 'Miss chance', Min = 0, Max = 100, Default = 0, Suffix = '%', Rounding = 0 })

	Groups.HitTiming = Tabs.Main:AddRightTabbox('Hit timing')
	Groups.ManualTiming = Groups.HitTiming:AddTab('Manual delay')
	Groups.ManualTiming:AddSlider('ReleaseDelay',   { Text = 'Release delay (ms)',  Min = 0,   Max = 500, Default = 20, Rounding = 0 })
	Groups.ManualTiming:AddSlider('HeldDelay',      { Text = 'Held delay (ms)',     Min = -20, Max = 100, Default = 0,  Rounding = 0 })

	Groups.RandomTiming = Groups.HitTiming:AddTab('Random delay')
	Groups.RandomTiming:AddSlider('NoteDelayMin',   { Text = 'Minimum note delay (ms)', Min = 0, Max = 500, Default = 0,    Rounding = 0 })
	Groups.RandomTiming:AddSlider('NoteDelayMax',   { Text = 'Maximum note delay (ms)', Min = 0, Max = 100, Default = 20,   Rounding = 0 })

	Groups.RandomTiming:AddSlider('HeldDelayMin',   { Text = 'Minimum held note delay (ms)', Min = 0, Max = 500, Default = 0,   Rounding = 0 })
	Groups.RandomTiming:AddSlider('HeldDelayMax',   { Text = 'Maximum held note delay (ms)', Min = 0, Max = 100, Default = 20,  Rounding = 0 })

	Groups.Keybinds = Tabs.Main:AddRightGroupbox('Keybinds')
	Groups.Keybinds:AddLabel('Sick'):AddKeyPicker('SickBind', { Default = 'One', NoUI = true })
	Groups.Keybinds:AddLabel('Good'):AddKeyPicker('GoodBind', { Default = 'Two', NoUI = true })
	Groups.Keybinds:AddLabel('Ok'):AddKeyPicker('OkayBind', { Default = 'Three', NoUI = true })
	Groups.Keybinds:AddLabel('Bad'):AddKeyPicker('BadBind', { Default = 'Four', NoUI = true })

	Groups.Configs = Tabs.Miscellaneous:AddRightGroupbox('Configs')
	Groups.Credits = Tabs.Miscellaneous:AddRightGroupbox('Credits')
	Groups.Credits:AddLabel('<font color="#3da5ff">wally</font> - script')
	Groups.Credits:AddLabel('<font color="#de6cff">Sezei</font> - contributor')
	Groups.Credits:AddLabel('Inori - ui library')
	Groups.Credits:AddLabel('Jan - old ui library')

	Groups.Unlockables = Tabs.Miscellaneous:AddRightGroupbox('Unlockables')
	Groups.Unlockables:AddButton('Unlock developer notes', ActivateUnlockables)

	Groups.Misc = Tabs.Miscellaneous:AddRightGroupbox('Miscellaneous')
	Groups.Misc:AddLabel(metadata.message or 'no message found!', true)

	Groups.Misc:AddDivider()
	Groups.Misc:AddButton('Unload script', function() pcall(shared._unload) end)
	Groups.Misc:AddButton('Copy discord', function()
		if pcall(setclipboard, "https://wally.cool/discord") then
			UI:Notify('Successfully copied discord link to your clipboard!', 5)
		end
	end)

	Groups.Misc:AddLabel('Menu toggle'):AddKeyPicker('MenuToggle', { Default = 'Delete', NoUI = true })

	UI.ToggleKeybind = Options.MenuToggle

	if type(readfile) == 'function' and type(writefile) == 'function' and type(makefolder) == 'function' and type(isfolder) == 'function' then
		makefolder('funky_friday_autoplayer')
		makefolder('funky_friday_autoplayer\\configs')

		Groups.Configs:AddDropdown('ConfigList', { Text = 'Config list', Values = {} })
		Groups.Configs:AddInput('ConfigName',    { Text = 'Config name' })

		Groups.Configs:AddDivider()

		Groups.Configs:AddButton('Save config', function()
			local name = Options.ConfigName.Value;
			if name:gsub(' ', '') == '' then
				return UI:Notify('Invalid config name.', 3)
			end

			local success, err = SaveManager:Save(name)
			if not success then
				return UI:Notify(tostring(err), 5)
			end

			UI:Notify(string.format('Saved config %q', name), 5)
			task.defer(SaveManager.Refresh)
		end)

		Groups.Configs:AddButton('Load', function()
			local name = Options.ConfigList.Value
			local success, err = SaveManager:Load(name)
			if not success then
				return UI:Notify(tostring(err), 5)
			end

			UI:Notify(string.format('Loaded config %q', name), 5)
		end):AddButton('Delete', function()
			local name = Options.ConfigList.Value
			if name:gsub(' ', '') == '' then
				return UI:Notify('Invalid config name.', 3)
			end

			local success, err = SaveManager:Delete(name)
			if not success then
				return UI:Notify(tostring(err), 5)
			end

			UI:Notify(string.format('Deleted config %q', name), 5)

			task.spawn(Options.ConfigList.SetValue, Options.ConfigList, nil)
			task.defer(SaveManager.Refresh)
		end)

		Groups.Configs:AddButton('Refresh list', SaveManager.Refresh)

		task.defer(SaveManager.Refresh)
		task.defer(SaveManager.Check)
	else
		Groups.Configs:AddLabel('Your exploit is missing file functions so you are unable to use configs.', true)
		--UI:Notify('Failed to create configs tab due to your exploit missing certain file functions.', 2)
	end

	-- Themes
	do
		local latestThemeIndex = 0
		for i, theme in next, themeManager.BuiltInThemes do
			if theme[1] > latestThemeIndex then
				latestThemeIndex = theme[1]
			end
		end

		latestThemeIndex = latestThemeIndex + 1

		local linoriaTheme = themeManager.BuiltInThemes.Default[2]
		local funkyFridayTheme = table.clone(themeManager.BuiltInThemes.Default[2])

		funkyFridayTheme.AccentColor = Color3.fromRGB(255, 65, 65):ToHex()

		themeManager.BuiltInThemes['Linoria'] = { latestThemeIndex, linoriaTheme }
		themeManager.BuiltInThemes['Default'] = { 1, funkyFridayTheme }

		themeManager:SetLibrary(UI)
		themeManager:SetFolder('funky_friday_autoplayer')
		themeManager:ApplyToGroupbox(Tabs.Miscellaneous:AddLeftGroupbox('Themes'))

		SaveManager:SetIgnoreIndexes({ 
			"BackgroundColor", "MainColor", "AccentColor", "OutlineColor", "FontColor", -- themes
			"ThemeManager_ThemeList", 'ThemeManager_CustomThemeList', 'ThemeManager_CustomThemeName', -- themes
		})
	end

	UI:Notify(string.format('Loaded script in %.4f second(s)!', tick() - start), 3)
end)

UICorner_11.Parent = FNFAutoPlay

Frame_2.Parent = AtlasHub
Frame_2.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Frame_2.BorderColor3 = Color3.fromRGB(27, 42, 53)
Frame_2.BorderSizePixel = 0
Frame_2.Position = UDim2.new(0.558077455, 0, 0.0849514529, 0)
Frame_2.Size = UDim2.new(0, 6, 0, 377)

Frame_3.Parent = AtlasHub
Frame_3.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Frame_3.BorderSizePixel = 0
Frame_3.Position = UDim2.new(0, 0, 0.817961156, 0)
Frame_3.Size = UDim2.new(0, 418, 0, 5)

ImageLabel.Parent = AtlasHub
ImageLabel.BackgroundColor3 = Color3.fromRGB(27, 27, 27)
ImageLabel.Position = UDim2.new(0.0120160216, 0, 0.847087383, 0)
ImageLabel.Size = UDim2.new(0, 54, 0, 54)
ImageLabel.Image = "rbxasset://textures/ui/GuiImagePlaceholder.png"

UICorner_12.CornerRadius = UDim.new(200, 200)
UICorner_12.Parent = ImageLabel

TextLabel.Parent = AtlasHub
TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel.BackgroundTransparency = 1.000
TextLabel.BorderSizePixel = 0
TextLabel.Position = UDim2.new(0.0841121525, 0, 0.864077687, 0)
TextLabel.Size = UDim2.new(0, 161, 0, 39)
TextLabel.Font = Enum.Font.SourceSansBold
TextLabel.Text = "NameHere"
TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
TextLabel.TextScaled = true
TextLabel.TextSize = 14.000
TextLabel.TextWrapped = true

Frame_4.Parent = AtlasHub
Frame_4.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Frame_4.BorderSizePixel = 0
Frame_4.Position = UDim2.new(0.299065411, 0, 0.830097079, 0)
Frame_4.Size = UDim2.new(0, 194, 0, 70)

neko.Name = "neko"
neko.Parent = AtlasHub
neko.BackgroundColor3 = Color3.fromRGB(27, 27, 27)
neko.Position = UDim2.new(0.375166893, 0, 0.106796116, 0)
neko.Size = UDim2.new(0, 125, 0, 97)
neko.Font = Enum.Font.Nunito
neko.Text = "FE Neko"
neko.TextColor3 = Color3.fromRGB(255, 255, 255)
neko.TextScaled = true
neko.TextSize = 14.000
neko.TextWrapped = true
neko.MouseButton1Down:connect(function()
	local NotificationBindable = Instance.new("BindableFunction")
	local Msgreq = function(Title,Text,Duration,Button1Text,Button2Text)
		game.StarterGui:SetCore("SendNotification", {
			Title = Title;
			Text = Text;
			Icon = "";
			Duration = Duration;
			Button1 = Button1Text;
			Button2 = nil;
			Callback = NotificationBindable;
		})
	end

	Msgreq("FE Neko Anims V1.6","Loading, please wait while it loads",5,nil)
	local SongID = "http://www.roblox.com/asset/?id=198665867"
	Bypass = "death"
	if not Bypass then Bypass = "limbs" end
	HumanDied = false

	CountSCIFIMOVIELOL = 1
	function SCIFIMOVIELOL(Part0,Part1,Position,Angle)
		local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..CountSCIFIMOVIELOL
		AlignPos.ApplyAtCenterOfMass = true;
		AlignPos.MaxForce = 67752;
		AlignPos.MaxVelocity = math.huge/9e110;
		AlignPos.ReactionForceEnabled = false;
		AlignPos.Responsiveness = 200;
		AlignPos.RigidityEnabled = false;
		local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..CountSCIFIMOVIELOL
		AlignOri.MaxAngularVelocity = math.huge/9e110;
		AlignOri.MaxTorque = 67752;
		AlignOri.PrimaryAxisOnly = false;
		AlignOri.ReactionTorqueEnabled = false;
		AlignOri.Responsiveness = 200;
		AlignOri.RigidityEnabled = false;
		local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "AthP_"..CountSCIFIMOVIELOL
		local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "AthP_"..CountSCIFIMOVIELOL
		local AttachmentC=Instance.new('Attachment',Part1); AttachmentC.Name = "AthO_"..CountSCIFIMOVIELOL
		local AttachmentD=Instance.new('Attachment',Part0); AttachmentD.Name = "AthO_"..CountSCIFIMOVIELOL
		AttachmentC.Orientation = Angle
		AttachmentA.Position = Position
		AlignPos.Attachment1 = AttachmentA;
		AlignPos.Attachment0 = AttachmentB;
		AlignOri.Attachment1 = AttachmentC;
		AlignOri.Attachment0 = AttachmentD;
		CountSCIFIMOVIELOL = CountSCIFIMOVIELOL + 1

	end

	coroutine.wrap(function()
		local player = game.Players.LocalPlayer
		local char = player.Character or player.CharacterAdded:wait()
		if sethiddenproperty then
			while true do
				game:GetService("RunService").RenderStepped:Wait()
				settings().Physics.AllowSleep = false
				local TBL = game:GetService("Players"):GetChildren() 
				for _ = 1,#TBL do local Players = TBL[_]
					if Players ~= game:GetService("Players").LocalPlayer then
						Players.MaximumSimulationRadius = 0
						sethiddenproperty(Players,"SimulationRadius",0) 
					end 
				end
				game:GetService("Players").LocalPlayer.MaximumSimulationRadius = math.pow(math.huge,math.huge)
				sethiddenproperty(game:GetService("Players").LocalPlayer,"SimulationRadius",math.pow(math.huge,math.huge)*math.huge)
				if HumanDied then break end
			end
		else
			while true do
				game:GetService("RunService").RenderStepped:Wait()
				settings().Physics.AllowSleep = false
				local TBL = game:GetService("Players"):GetChildren() 
				for _ = 1,#TBL do local Players = TBL[_]
					if Players ~= game:GetService("Players").LocalPlayer then
						Players.MaximumSimulationRadius = 0
					end 
				end
				game:GetService("Players").LocalPlayer.MaximumSimulationRadius = math.pow(math.huge,math.huge)
				if HumanDied then break end
			end
		end
	end)()

	if game:GetService("Players").LocalPlayer.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 then
		if Bypass == "limbs" then --------------------------------------------------------------------------------------------------------------------
			game:GetService("Players").LocalPlayer["Character"].Archivable = true 
			local CloneChar = game:GetService("Players").LocalPlayer["Character"]:Clone()
			CloneChar.Parent = workspace 
			CloneChar.HumanoidRootPart.CFrame = game:GetService("Players").LocalPlayer["Character"].HumanoidRootPart.CFrame * CFrame.new(0,2,0)
			wait() 
			CloneChar.Humanoid.BreakJointsOnDeath = false
			workspace.Camera.CameraSubject = CloneChar.Humanoid
			CloneChar.Name = "non" 
			CloneChar.Humanoid.DisplayDistanceType = "None"
			if CloneChar.Head:FindFirstChild("face") then CloneChar.Head:FindFirstChild("face"):Destroy() end
			if workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face") then workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face").Parent = CloneChar.Head end

			local DeadChar = workspace[game:GetService("Players").LocalPlayer.Name]
			DeadChar.HumanoidRootPart:Destroy()

			local LVecPart = Instance.new("Part", workspace) LVecPart.CanCollide = false LVecPart.Transparency = 1
			local CONVEC
			local function VECTORUNIT()
				if HumanDied then CONVEC:Disconnect(); return end
				local lookVec = workspace.Camera.CFrame.lookVector
				local Root = CloneChar["HumanoidRootPart"]
				LVecPart.Position = Root.Position
				LVecPart.CFrame = CFrame.new(LVecPart.Position, Vector3.new(lookVec.X * 9999, lookVec.Y, lookVec.Z * 9999))
			end
			CONVEC = game:GetService("RunService").Heartbeat:Connect(VECTORUNIT)

			local CONDOWN
			local WDown, ADown, SDown, DDown, SpaceDown = false, false, false, false, false
			local function KEYDOWN(_,Processed) 
				if HumanDied then CONDOWN:Disconnect(); return end
				if Processed ~= true then
					local Key = _.KeyCode
					if Key == Enum.KeyCode.W then
						WDown = true end
					if Key == Enum.KeyCode.A then
						ADown = true end
					if Key == Enum.KeyCode.S then
						SDown = true end
					if Key == Enum.KeyCode.D then
						DDown = true end
					if Key == Enum.KeyCode.Space then
						SpaceDown = true end end end
			CONDOWN = game:GetService("UserInputService").InputBegan:Connect(KEYDOWN)

			local CONUP
			local function KEYUP(_)
				if HumanDied then CONUP:Disconnect(); return end
				local Key = _.KeyCode
				if Key == Enum.KeyCode.W then
					WDown = false end
				if Key == Enum.KeyCode.A then
					ADown = false end
				if Key == Enum.KeyCode.S then
					SDown = false end
				if Key == Enum.KeyCode.D then
					DDown = false end
				if Key == Enum.KeyCode.Space then
					SpaceDown = false end end
			CONUP = game:GetService("UserInputService").InputEnded:Connect(KEYUP)

			local function MoveClone(X,Y,Z)
				LVecPart.CFrame = LVecPart.CFrame * CFrame.new(-X,Y,-Z)
				workspace["non"].Humanoid.WalkToPoint = LVecPart.Position
			end

			coroutine.wrap(function() 
				while true do game:GetService("RunService").RenderStepped:Wait()
					if HumanDied then break end
					if WDown then MoveClone(0,0,1e4) end
					if ADown then MoveClone(1e4,0,0) end
					if SDown then MoveClone(0,0,-1e4) end
					if DDown then MoveClone(-1e4,0,0) end
					if SpaceDown then CloneChar["Humanoid"].Jump = true end
					if WDown ~= true and ADown ~= true and SDown ~= true and DDown ~= true then
						workspace["non"].Humanoid.WalkToPoint = workspace["non"].HumanoidRootPart.Position end
				end 
			end)()

			local con
			function UnCollide()
				if HumanDied then con:Disconnect(); return end
				for _,Parts in next, CloneChar:GetDescendants() do
					if Parts:IsA("BasePart") then
						Parts.CanCollide = false 
					end 
				end
				for _,Parts in next, DeadChar:GetDescendants() do
					if Parts:IsA("BasePart") then
						Parts.CanCollide = false
					end 
				end 
			end
			con = game:GetService("RunService").Stepped:Connect(UnCollide)

			local resetBindable = Instance.new("BindableEvent")
			resetBindable.Event:connect(function()
				game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
				resetBindable:Destroy()
				pcall(function()
					CloneChar.Humanoid.Health = 0
					DeadChar.Humanoid.Health = 0
				end)
			end)
			game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

			coroutine.wrap(function()
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChild("Humanoid") or CloneChar:FindFirstChild("Humanoid").Health <= 0 or not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChild("Humanoid") or DeadChar:FindFirstChild("Humanoid").Health <= 0 then 
						HumanDied = true
						pcall(function()
							game.Players.LocalPlayer.Character = CloneChar
							CloneChar:Destroy()
							game.Players.LocalPlayer.Character = DeadChar
							if resetBindable then
								game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
								resetBindable:Destroy()
							end
							DeadChar.Humanoid.Health = 0
						end)
						break
					end		
				end
			end)()

			SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["Torso"],CloneChar["Torso"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["Left Arm"],CloneChar["Left Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["Right Arm"],CloneChar["Right Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["Left Leg"],CloneChar["Left Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["Right Leg"],CloneChar["Right Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))

			coroutine.wrap(function()
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if HumanDied then break end
					DeadChar["Torso"].CFrame = CloneChar["Torso"].CFrame
				end
			end)()

			for _,v in next, DeadChar:GetChildren() do
				if v:IsA("Accessory") then
					SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
				end
			end

			for _,BodyParts in next, CloneChar:GetDescendants() do
				if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
					BodyParts.Transparency = 1 end end

			DeadChar.Torso["Left Shoulder"]:Destroy()
			DeadChar.Torso["Right Shoulder"]:Destroy()
			DeadChar.Torso["Left Hip"]:Destroy()
			DeadChar.Torso["Right Hip"]:Destroy()

		elseif Bypass == "death" then --------------------------------------------------------------------------------------------------------------------
			game:GetService("Players").LocalPlayer["Character"].Archivable = true 
			local CloneChar = game:GetService("Players").LocalPlayer["Character"]:Clone()
			game:GetService("Players").LocalPlayer["Character"].Humanoid.WalkSpeed = 0 
			game:GetService("Players").LocalPlayer["Character"].Humanoid.JumpPower = 0 
			game:GetService("Players").LocalPlayer["Character"].Humanoid.AutoRotate = false
			local FalseChar = Instance.new("Model", workspace); FalseChar.Name = ""
			Instance.new("Part",FalseChar).Name = "Head" 
			Instance.new("Part",FalseChar).Name = "Torso" 
			Instance.new("Humanoid",FalseChar).Name = "Humanoid"
			game:GetService("Players").LocalPlayer["Character"] = FalseChar
			game:GetService("Players").LocalPlayer["Character"].Humanoid.Name = "FalseHumanoid"
			local Clone = game:GetService("Players").LocalPlayer["Character"]:FindFirstChild("FalseHumanoid"):Clone()
			Clone.Parent = game:GetService("Players").LocalPlayer["Character"]
			Clone.Name = "Humanoid"
			game:GetService("Players").LocalPlayer["Character"]:FindFirstChild("FalseHumanoid"):Destroy() 
			game:GetService("Players").LocalPlayer["Character"].Humanoid.Health = 0 
			game:GetService("Players").LocalPlayer["Character"] = workspace[game:GetService("Players").LocalPlayer.Name] 
			wait(5.65) 
			game:GetService("Players").LocalPlayer["Character"].Humanoid.Health = 0
			CloneChar.Parent = workspace 
			CloneChar.HumanoidRootPart.CFrame = game:GetService("Players").LocalPlayer["Character"].HumanoidRootPart.CFrame * CFrame.new(0,2,0)
			wait() 
			CloneChar.Humanoid.BreakJointsOnDeath = false
			workspace.Camera.CameraSubject = CloneChar.Humanoid 
			CloneChar.Name = "non" 
			CloneChar.Humanoid.DisplayDistanceType = "None"
			if CloneChar.Head:FindFirstChild("face") then CloneChar.Head:FindFirstChild("face"):Destroy() end
			if workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face") then workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face").Parent = CloneChar.Head end

			FalseChar:Destroy()

			local DeadChar = workspace[game:GetService("Players").LocalPlayer.Name]

			local LVecPart = Instance.new("Part", workspace) LVecPart.CanCollide = false LVecPart.Transparency = 1
			local CONVEC
			local function VECTORUNIT()
				if HumanDied then CONVEC:Disconnect(); return end
				local lookVec = workspace.Camera.CFrame.lookVector
				local Root = CloneChar["HumanoidRootPart"]
				LVecPart.Position = Root.Position
				LVecPart.CFrame = CFrame.new(LVecPart.Position, Vector3.new(lookVec.X * 9999, lookVec.Y, lookVec.Z * 9999))
			end
			CONVEC = game:GetService("RunService").Heartbeat:Connect(VECTORUNIT)

			local CONDOWN
			local WDown, ADown, SDown, DDown, SpaceDown = false, false, false, false, false
			local function KEYDOWN(_,Processed) 
				if HumanDied then CONDOWN:Disconnect(); return end
				if Processed ~= true then
					local Key = _.KeyCode
					if Key == Enum.KeyCode.W then
						WDown = true end
					if Key == Enum.KeyCode.A then
						ADown = true end
					if Key == Enum.KeyCode.S then
						SDown = true end
					if Key == Enum.KeyCode.D then
						DDown = true end
					if Key == Enum.KeyCode.Space then
						SpaceDown = true end end end
			CONDOWN = game:GetService("UserInputService").InputBegan:Connect(KEYDOWN)

			local CONUP
			local function KEYUP(_)
				if HumanDied then CONUP:Disconnect(); return end
				local Key = _.KeyCode
				if Key == Enum.KeyCode.W then
					WDown = false end
				if Key == Enum.KeyCode.A then
					ADown = false end
				if Key == Enum.KeyCode.S then
					SDown = false end
				if Key == Enum.KeyCode.D then
					DDown = false end
				if Key == Enum.KeyCode.Space then
					SpaceDown = false end end
			CONUP = game:GetService("UserInputService").InputEnded:Connect(KEYUP)

			local function MoveClone(X,Y,Z)
				LVecPart.CFrame = LVecPart.CFrame * CFrame.new(-X,Y,-Z)
				workspace["non"].Humanoid.WalkToPoint = LVecPart.Position
			end

			coroutine.wrap(function() 
				while true do game:GetService("RunService").RenderStepped:Wait()
					if HumanDied then break end
					if WDown then MoveClone(0,0,1e4) end
					if ADown then MoveClone(1e4,0,0) end
					if SDown then MoveClone(0,0,-1e4) end
					if DDown then MoveClone(-1e4,0,0) end
					if SpaceDown then CloneChar["Humanoid"].Jump = true end
					if WDown ~= true and ADown ~= true and SDown ~= true and DDown ~= true then
						workspace["non"].Humanoid.WalkToPoint = workspace["non"].HumanoidRootPart.Position end
				end 
			end)()

			local con
			function UnCollide()
				if HumanDied then con:Disconnect(); return end
				for _,Parts in next, CloneChar:GetDescendants() do
					if Parts:IsA("BasePart") then
						Parts.CanCollide = false 
					end 
				end
				for _,Parts in next, DeadChar:GetDescendants() do
					if Parts:IsA("BasePart") then
						Parts.CanCollide = false
					end 
				end 
			end
			con = game:GetService("RunService").Stepped:Connect(UnCollide)

			local resetBindable = Instance.new("BindableEvent")
			resetBindable.Event:connect(function()
				game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
				resetBindable:Destroy()
				CloneChar.Humanoid.Health = 0
			end)
			game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

			coroutine.wrap(function()
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChild("Humanoid") or CloneChar:FindFirstChild("Humanoid").Health <= 0 then 
						HumanDied = true
						pcall(function()
							game.Players.LocalPlayer.Character = CloneChar
							CloneChar:Destroy()
							game.Players.LocalPlayer.Character = DeadChar
							if resetBindable then
								game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
								resetBindable:Destroy()
							end
							DeadChar.Humanoid.Health = 0
						end)
						break
					end		
				end
			end)()

			SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["Torso"],CloneChar["Torso"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["Left Arm"],CloneChar["Left Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["Right Arm"],CloneChar["Right Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["Left Leg"],CloneChar["Left Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["Right Leg"],CloneChar["Right Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["HumanoidRootPart"],CloneChar["HumanoidRootPart"],Vector3.new(0,0,0),Vector3.new(0,0,0))

			for _,v in next, DeadChar:GetChildren() do
				if v:IsA("Accessory") then
					if v.Name == "PlainTail" then
						Tail = CloneChar[v.Name].Handle
					end
					SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
				end
			end

			for _,BodyParts in next, CloneChar:GetDescendants() do
				if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
					BodyParts.Transparency = 1 end end
		elseif Bypass == "hats" then
			game:GetService("Players").LocalPlayer["Character"].Archivable = true 
			local DeadChar = game.Players.LocalPlayer.Character
			DeadChar.Name = "non"
			local HatPosition = Vector3.new(0,0,0)
			local HatName = "MediHood"
			local HatsLimb = {
				Rarm = DeadChar:FindFirstChild("Hat1"),
				Larm = DeadChar:FindFirstChild("Pink Hair"),
				Rleg = DeadChar:FindFirstChild("Robloxclassicred"),
				Lleg = DeadChar:FindFirstChild("Kate Hair"),
				Torso1 = DeadChar:FindFirstChild("Pal Hair"),
				Torso2 = DeadChar:FindFirstChild("LavanderHair")
			}
			HatName = DeadChar:FindFirstChild(HatName)

			coroutine.wrap(function()
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChild("Humanoid") or DeadChar:FindFirstChild("Humanoid").Health <= 0 then 
						HumanDied = true
						pcall(function()
							if resetBindable then
								game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
								resetBindable:Destroy()
							end
							DeadChar.Humanoid.Health = 0
						end)
						break
					end		
				end
			end)()

			local con
			function UnCollide()
				if HumanDied then con:Disconnect(); return end
				for _,Parts in next, DeadChar:GetDescendants() do
					if Parts:IsA("BasePart") then
						Parts.CanCollide = false
					end 
				end 
			end
			con = game:GetService("RunService").Stepped:Connect(UnCollide)

			SCIFIMOVIELOL(HatName.Handle,DeadChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(HatsLimb.Torso1.Handle,DeadChar["Torso"],Vector3.new(0.5,0,0),Vector3.new(90,0,0))
			SCIFIMOVIELOL(HatsLimb.Torso2.Handle,DeadChar["Torso"],Vector3.new(-0.5,0,0),Vector3.new(90,0,0))
			SCIFIMOVIELOL(HatsLimb.Larm.Handle,DeadChar["Left Arm"],Vector3.new(0,0,0),Vector3.new(90,0,0))
			SCIFIMOVIELOL(HatsLimb.Rarm.Handle,DeadChar["Right Arm"],Vector3.new(0,0,0),Vector3.new(90,0,0))
			SCIFIMOVIELOL(HatsLimb.Lleg.Handle,DeadChar["Left Leg"],Vector3.new(0,0,0),Vector3.new(90,0,0))
			SCIFIMOVIELOL(HatsLimb.Rleg.Handle,DeadChar["Right Leg"],Vector3.new(0,0,0),Vector3.new(90,0,0))

			for i,v in pairs(HatsLimb) do
				v.Handle:FindFirstChild("AccessoryWeld"):Destroy()
				if v.Handle:FindFirstChild("Mesh") then v.Handle:FindFirstChild("Mesh"):Destroy() end
				if v.Handle:FindFirstChild("SpecialMesh") then v.Handle:FindFirstChild("SpecialMesh"):Destroy() end
			end
			HatName.Handle:FindFirstChild("AccessoryWeld"):Destroy()
		end
	else
		if Bypass == "limbs" then --------------------------------------------------------------------------------------------------------------------
			game:GetService("Players").LocalPlayer["Character"].Archivable = true 
			local CloneChar = game:GetObjects("rbxassetid://5227463276")[1]
			CloneChar.Parent = workspace 
			CloneChar.HumanoidRootPart.CFrame = game:GetService("Players").LocalPlayer["Character"].HumanoidRootPart.CFrame * CFrame.new(0,0.5,0.1)
			CloneChar.Humanoid.BreakJointsOnDeath = false
			workspace.Camera.CameraSubject = CloneChar.Humanoid 
			CloneChar.Name = "non" 
			CloneChar.Humanoid.DisplayDistanceType = "None"
			if CloneChar.Head:FindFirstChild("face") then CloneChar.Head:FindFirstChild("face"):Destroy() end
			if workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face") then workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face").Parent = CloneChar.Head end

			local DeadChar = workspace[game:GetService("Players").LocalPlayer.Name]
			DeadChar.HumanoidRootPart:Destroy()

			local LVecPart = Instance.new("Part", workspace) LVecPart.CanCollide = false LVecPart.Transparency = 1
			local CONVEC
			local function VECTORUNIT()
				if HumanDied then CONVEC:Disconnect(); return end
				local lookVec = workspace.Camera.CFrame.lookVector
				local Root = CloneChar["HumanoidRootPart"]
				LVecPart.Position = Root.Position
				LVecPart.CFrame = CFrame.new(LVecPart.Position, Vector3.new(lookVec.X * 9999, lookVec.Y, lookVec.Z * 9999))
			end
			CONVEC = game:GetService("RunService").Heartbeat:Connect(VECTORUNIT)

			local CONDOWN
			local WDown, ADown, SDown, DDown, SpaceDown = false, false, false, false, false
			local function KEYDOWN(_,Processed) 
				if HumanDied then CONDOWN:Disconnect(); return end
				if Processed ~= true then
					local Key = _.KeyCode
					if Key == Enum.KeyCode.W then
						WDown = true end
					if Key == Enum.KeyCode.A then
						ADown = true end
					if Key == Enum.KeyCode.S then
						SDown = true end
					if Key == Enum.KeyCode.D then
						DDown = true end
					if Key == Enum.KeyCode.Space then
						SpaceDown = true end end end
			CONDOWN = game:GetService("UserInputService").InputBegan:Connect(KEYDOWN)

			local CONUP
			local function KEYUP(_)
				if HumanDied then CONUP:Disconnect(); return end
				local Key = _.KeyCode
				if Key == Enum.KeyCode.W then
					WDown = false end
				if Key == Enum.KeyCode.A then
					ADown = false end
				if Key == Enum.KeyCode.S then
					SDown = false end
				if Key == Enum.KeyCode.D then
					DDown = false end
				if Key == Enum.KeyCode.Space then
					SpaceDown = false end end
			CONUP = game:GetService("UserInputService").InputEnded:Connect(KEYUP)

			local function MoveClone(X,Y,Z)
				LVecPart.CFrame = LVecPart.CFrame * CFrame.new(-X,Y,-Z)
				workspace["non"].Humanoid.WalkToPoint = LVecPart.Position
			end

			coroutine.wrap(function() 
				while true do game:GetService("RunService").RenderStepped:Wait()
					if HumanDied then break end
					if WDown then MoveClone(0,0,1e4) end
					if ADown then MoveClone(1e4,0,0) end
					if SDown then MoveClone(0,0,-1e4) end
					if DDown then MoveClone(-1e4,0,0) end
					if SpaceDown then CloneChar["Humanoid"].Jump = true end
					if WDown ~= true and ADown ~= true and SDown ~= true and DDown ~= true then
						workspace["non"].Humanoid.WalkToPoint = workspace["non"].HumanoidRootPart.Position end
				end 
			end)()

			local con
			function UnCollide()
				if HumanDied then con:Disconnect(); return end
				for _,Parts in next, CloneChar:GetDescendants() do
					if Parts:IsA("BasePart") then
						Parts.CanCollide = false 
					end 
				end
				for _,Parts in next, DeadChar:GetDescendants() do
					if Parts:IsA("BasePart") then
						Parts.CanCollide = false
					end 
				end 
			end
			con = game:GetService("RunService").Stepped:Connect(UnCollide)

			local resetBindable = Instance.new("BindableEvent")
			resetBindable.Event:connect(function()
				game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
				resetBindable:Destroy()
				CloneChar.Humanoid.Health = 0
			end)
			game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

			coroutine.wrap(function()
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChild("Humanoid") or CloneChar:FindFirstChild("Humanoid").Health <= 0 or not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChild("Humanoid") or DeadChar:FindFirstChild("Humanoid").Health <= 0 then 
						HumanDied = true
						pcall(function()
							game.Players.LocalPlayer.Character = CloneChar
							CloneChar:Destroy()
							game.Players.LocalPlayer.Character = DeadChar
							if resetBindable then
								game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
								resetBindable:Destroy()
							end
							DeadChar.Humanoid.Health = 0
						end)
						break
					end		
				end
			end)()

			for _,v in next, DeadChar:GetChildren() do
				if v:IsA("Accessory") then
					v:Clone().Parent = CloneChar
				end
			end

			for _,v in next, DeadChar:GetDescendants() do
				if v:IsA("Motor6D") and v.Name ~= "Neck" then
					v:Destroy()
				end
			end

			SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["UpperTorso"],CloneChar["Torso"],Vector3.new(0,0.2,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LowerTorso"],CloneChar["Torso"],Vector3.new(0,-0.78,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LeftUpperArm"],CloneChar["Left Arm"],Vector3.new(0,0.375,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LeftLowerArm"],CloneChar["Left Arm"],Vector3.new(0,-0.215,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LeftHand"],CloneChar["Left Arm"],Vector3.new(0,-0.825,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightUpperArm"],CloneChar["Right Arm"],Vector3.new(0,0.375,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightLowerArm"],CloneChar["Right Arm"],Vector3.new(0,-0.215,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightHand"],CloneChar["Right Arm"],Vector3.new(0,-0.825,0),Vector3.new(0,0,0))

			SCIFIMOVIELOL(DeadChar["LeftUpperLeg"],CloneChar["Left Leg"],Vector3.new(0,0.575,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LeftLowerLeg"],CloneChar["Left Leg"],Vector3.new(0,-0.137,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LeftFoot"],CloneChar["Left Leg"],Vector3.new(0,-0.787,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightUpperLeg"],CloneChar["Right Leg"],Vector3.new(0,0.575,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightLowerLeg"],CloneChar["Right Leg"],Vector3.new(0,-0.137,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightFoot"],CloneChar["Right Leg"],Vector3.new(0,-0.787,0),Vector3.new(0,0,0))

			coroutine.wrap(function()
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if HumanDied then break end
					DeadChar["UpperTorso"].CFrame = CloneChar["Torso"].CFrame * CFrame.new(0,0.2,0)
				end
			end)()

			for _,v in next, DeadChar:GetChildren() do
				if v:IsA("Accessory") then
					SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
				end
			end

			for _,BodyParts in next, CloneChar:GetDescendants() do
				if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
					BodyParts.Transparency = 1 end end

		elseif Bypass == "death" then --------------------------------------------------------------------------------------------------------------------
			game:GetService("Players").LocalPlayer["Character"].Archivable = true 
			local CloneChar = game:GetObjects("rbxassetid://5227463276")[1]
			game:GetService("Players").LocalPlayer["Character"].Humanoid.WalkSpeed = 0 
			game:GetService("Players").LocalPlayer["Character"].Humanoid.JumpPower = 0 
			game:GetService("Players").LocalPlayer["Character"].Humanoid.AutoRotate = false
			local FalseChar = Instance.new("Model", workspace); FalseChar.Name = ""
			Instance.new("Part",FalseChar).Name = "Head" 
			Instance.new("Part",FalseChar).Name = "UpperTorso"
			Instance.new("Humanoid",FalseChar).Name = "Humanoid"
			game:GetService("Players").LocalPlayer["Character"] = FalseChar
			game:GetService("Players").LocalPlayer["Character"].Humanoid.Name = "FalseHumanoid"
			local Clone = game:GetService("Players").LocalPlayer["Character"]:FindFirstChild("FalseHumanoid"):Clone()
			Clone.Parent = game:GetService("Players").LocalPlayer["Character"]
			Clone.Name = "Humanoid"
			game:GetService("Players").LocalPlayer["Character"]:FindFirstChild("FalseHumanoid"):Destroy() 
			game:GetService("Players").LocalPlayer["Character"].Humanoid.Health = 0 
			game:GetService("Players").LocalPlayer["Character"] = workspace[game:GetService("Players").LocalPlayer.Name] 
			wait(5.65) 
			game:GetService("Players").LocalPlayer["Character"].Humanoid.Health = 0
			CloneChar.Parent = workspace 
			CloneChar.HumanoidRootPart.CFrame = game:GetService("Players").LocalPlayer["Character"].HumanoidRootPart.CFrame * CFrame.new(0,0.5,0.1)
			wait() 
			CloneChar.Humanoid.BreakJointsOnDeath = false
			workspace.Camera.CameraSubject = CloneChar.Humanoid 
			CloneChar.Name = "non" 
			CloneChar.Humanoid.DisplayDistanceType = "None"
			if CloneChar.Head:FindFirstChild("face") then CloneChar.Head:FindFirstChild("face"):Destroy() end
			if workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face") then workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face").Parent = CloneChar.Head end

			FalseChar:Destroy()

			local DeadChar = workspace[game:GetService("Players").LocalPlayer.Name]

			local LVecPart = Instance.new("Part", workspace) LVecPart.CanCollide = false LVecPart.Transparency = 1
			local CONVEC
			local function VECTORUNIT()
				if HumanDied then CONVEC:Disconnect(); return end
				local lookVec = workspace.Camera.CFrame.lookVector
				local Root = CloneChar["HumanoidRootPart"]
				LVecPart.Position = Root.Position
				LVecPart.CFrame = CFrame.new(LVecPart.Position, Vector3.new(lookVec.X * 9999, lookVec.Y, lookVec.Z * 9999))
			end
			CONVEC = game:GetService("RunService").Heartbeat:Connect(VECTORUNIT)

			local CONDOWN
			local WDown, ADown, SDown, DDown, SpaceDown = false, false, false, false, false
			local function KEYDOWN(_,Processed) 
				if HumanDied then CONDOWN:Disconnect(); return end
				if Processed ~= true then
					local Key = _.KeyCode
					if Key == Enum.KeyCode.W then
						WDown = true end
					if Key == Enum.KeyCode.A then
						ADown = true end
					if Key == Enum.KeyCode.S then
						SDown = true end
					if Key == Enum.KeyCode.D then
						DDown = true end
					if Key == Enum.KeyCode.Space then
						SpaceDown = true end end end
			CONDOWN = game:GetService("UserInputService").InputBegan:Connect(KEYDOWN)

			local CONUP
			local function KEYUP(_)
				if HumanDied then CONUP:Disconnect(); return end
				local Key = _.KeyCode
				if Key == Enum.KeyCode.W then
					WDown = false end
				if Key == Enum.KeyCode.A then
					ADown = false end
				if Key == Enum.KeyCode.S then
					SDown = false end
				if Key == Enum.KeyCode.D then
					DDown = false end
				if Key == Enum.KeyCode.Space then
					SpaceDown = false end end
			CONUP = game:GetService("UserInputService").InputEnded:Connect(KEYUP)

			local function MoveClone(X,Y,Z)
				LVecPart.CFrame = LVecPart.CFrame * CFrame.new(-X,Y,-Z)
				workspace["non"].Humanoid.WalkToPoint = LVecPart.Position
			end

			coroutine.wrap(function() 
				while true do game:GetService("RunService").RenderStepped:Wait()
					if HumanDied then break end
					if WDown then MoveClone(0,0,1e4) end
					if ADown then MoveClone(1e4,0,0) end
					if SDown then MoveClone(0,0,-1e4) end
					if DDown then MoveClone(-1e4,0,0) end
					if SpaceDown then CloneChar["Humanoid"].Jump = true end
					if WDown ~= true and ADown ~= true and SDown ~= true and DDown ~= true then
						workspace["non"].Humanoid.WalkToPoint = workspace["non"].HumanoidRootPart.Position end
				end 
			end)()

			local con
			function UnCollide()
				if HumanDied then con:Disconnect(); return end
				for _,Parts in next, CloneChar:GetDescendants() do
					if Parts:IsA("BasePart") then
						Parts.CanCollide = false 
					end 
				end
				for _,Parts in next, DeadChar:GetDescendants() do
					if Parts:IsA("BasePart") then
						Parts.CanCollide = false
					end 
				end 
			end
			con = game:GetService("RunService").Stepped:Connect(UnCollide)

			local resetBindable = Instance.new("BindableEvent")
			resetBindable.Event:connect(function()
				game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
				resetBindable:Destroy()
				CloneChar.Humanoid.Health = 0
			end)
			game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

			coroutine.wrap(function()
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChild("Humanoid") or CloneChar:FindFirstChild("Humanoid").Health <= 0 then 
						HumanDied = true
						pcall(function()
							game.Players.LocalPlayer.Character = CloneChar
							CloneChar:Destroy()
							game.Players.LocalPlayer.Character = DeadChar
							if resetBindable then
								game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
								resetBindable:Destroy()
							end
							DeadChar.Humanoid.Health = 0
						end)
						break
					end		
				end
			end)()

			for _,v in next, DeadChar:GetChildren() do
				if v:IsA("Accessory") then
					v:Clone().Parent = CloneChar
				end
			end

			SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["UpperTorso"],CloneChar["Torso"],Vector3.new(0,0.2,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LowerTorso"],CloneChar["Torso"],Vector3.new(0,-0.78,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LeftUpperArm"],CloneChar["Left Arm"],Vector3.new(0,0.375,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LeftLowerArm"],CloneChar["Left Arm"],Vector3.new(0,-0.215,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LeftHand"],CloneChar["Left Arm"],Vector3.new(0,-0.825,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightUpperArm"],CloneChar["Right Arm"],Vector3.new(0,0.375,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightLowerArm"],CloneChar["Right Arm"],Vector3.new(0,-0.215,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightHand"],CloneChar["Right Arm"],Vector3.new(0,-0.825,0),Vector3.new(0,0,0))

			SCIFIMOVIELOL(DeadChar["LeftUpperLeg"],CloneChar["Left Leg"],Vector3.new(0,0.575,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LeftLowerLeg"],CloneChar["Left Leg"],Vector3.new(0,-0.137,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["LeftFoot"],CloneChar["Left Leg"],Vector3.new(0,-0.787,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightUpperLeg"],CloneChar["Right Leg"],Vector3.new(0,0.575,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightLowerLeg"],CloneChar["Right Leg"],Vector3.new(0,-0.137,0),Vector3.new(0,0,0))
			SCIFIMOVIELOL(DeadChar["RightFoot"],CloneChar["Right Leg"],Vector3.new(0,-0.787,0),Vector3.new(0,0,0))

			SCIFIMOVIELOL(DeadChar["HumanoidRootPart"],CloneChar["HumanoidRootPart"],Vector3.new(0,0,0),Vector3.new(0,0,0))

			for _,v in next, DeadChar:GetChildren() do
				if v:IsA("Accessory") then
					SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
				end
			end

			for _,BodyParts in next, CloneChar:GetDescendants() do
				if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
					BodyParts.Transparency = 1 end end
			if DeadChar.Head:FindFirstChild("Neck") then
				game.Players.LocalPlayer.Character:BreakJoints()
			end
		end
	end
	local CloneChar = workspace.non







	ArtificialHB = Instance.new('BindableEvent', script)
	ArtificialHB.Name = 'Heartbeat'
	script:WaitForChild('Heartbeat')
	frame = 1 / 60
	tf = 0
	allowframeloss = false
	tossremainder = false
	lastframe = tick()
	script.Heartbeat:Fire()

	game:GetService('RunService').Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				script.Heartbeat:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					script.Heartbeat:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)
	local makesound = function(soundid,speed,volume,parent)
		local sound = Instance.new("Sound")
		sound.SoundId = soundid
		sound.RollOffMaxDistance = 100
		sound.PlaybackSpeed =speed 
		sound.Volume = volume
		sound.Parent = parent
		return sound
	end
	local Callerp = function(Start,End,Percent)
		return (Start - (End - Start) * Percen)
	end
	function swait(t)
		game:GetService('RunService').Stepped:wait()
	end

	local TweenService = game:GetService("TweenService")
	local CF = CFrame.new
	local CFA = CFrame.Angles
	local head = CloneChar:WaitForChild("Head")
	local tors = CloneChar:WaitForChild("Torso")
	local huma = CloneChar:WaitForChild("Humanoid")
	huma.DisplayName = " "
	local neck = Instance.new("Weld",tors)
	neck.Part0 = tors
	neck.Part1 = head
	neck.C0 = CF(0,1.5,0)
	local nek = neck.C1
	neck.Enabled = true
	local root = CloneChar.HumanoidRootPart.RootJoint.C0
	local rs = tors["Right Shoulder"].C0
	local ls = tors["Left Shoulder"].C0
	local rh = tors["Right Hip"].C0
	local lh = tors["Left Hip"].C0
	local RootPart = CloneChar:WaitForChild("HumanoidRootPart")
	local Humanoid = CloneChar.Humanoid
	local ActiveTracks = Humanoid:GetPlayingAnimationTracks()
	Humanoid.JumpPower = 80
	local Attacking = false
	local AttackANVal = 1
	local bambam = Instance.new("BodyThrust")
	bambam.Parent = game.Players.LocalPlayer.Character.HumanoidRootPart
	bambam.Force = Vector3.new(1000,0,1000)
	bambam.Location = game.Players.LocalPlayer.Character.HumanoidRootPart.Position
	rayCast = function(Pos, Dir, Max, Ignore)

		return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), (CloneChar and game.Players.LocalPlayer.Character))
	end
	Spawn(function()
		for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
			if v:IsA("BasePart") and v.Name ~="HumanoidRootPart" then 
				s = game:GetService("RunService").Heartbeat:connect(function()
					v.Velocity = Vector3.new(0,35,0)
					wait(0.3)
				end)
			end
		end
	end)
	spawn(function()
		repeat
			wait()
		until Humanoid.Health < 0.1
		s:Disconnect()
	end)
	if Tail ~= nil then
		TailWeld = Tail.AccessoryWeld

	else
		TailWeld = Instance.new("Weld",workspace)
		Msgreq("FE Neko Anims V1.6","Loading Without Tail Accessory (Check top of script for the accessory)",5,nil)
	end
	local TC0 = TailWeld.C0 * CFrame.new(0,0,0.4)
	local Song = Instance.new("Sound",RootPart)
	Song.SoundId = SongID
	Song.Looped = true
	Song:Play()
	local Running = false

	local MakeTween = function(timetack,easingstyle,easingdirection,repeats,flipflop)
		local newtween = TweenInfo.new(
			timetack, 
			easingstyle, 
			easingdirection, 
			repeats, 
			flipflop, 
			0 
		)
		return newtween
	end
	local DOTWEEN = function(Part,tim,value)
		local Tween = MakeTween(tim,Enum.EasingStyle.Circular,Enum.EasingDirection.InOut,0,false)
		TweenService:Create(Part,Tween,{C0= value}):Play()
	end
	local LerpStyle = function(lerpmagnet,easingstyle,easingdirection)
		local newstyle = TweenService:GetValue(lerpmagnet,easingstyle,easingdirection)
		return newstyle
	end

	local SpinKick  = function()
		if Attacking == false then
			Attacking = true 
			for i = 0,60,1 do
				swait()
				neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(30),math.rad(0),math.rad(0)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0.0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-20)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(20)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-20 + -10)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-30 - -6)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
			end 
			bambam.Location = game.Players.LocalPlayer.Character.Torso.Position
			game.Players.LocalPlayer.Character.HumanoidRootPart.Position = game.Players.LocalPlayer.Character.Torso.Position
			RootPart.Anchored = true
			for i = 0,60,1 do
				swait()
				RootPart.Position = RootPart.Position + Vector3.new(0,0.6,0)
				bambam.Location = game.Players.LocalPlayer.Character["Right Leg"].Position
				game.Players.LocalPlayer.Character.HumanoidRootPart.Position = game.Players.LocalPlayer.Character.Torso.Position
				neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(-20 + -36*i),math.rad(0),math.rad(0)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0.0,0,0) * CFA(math.rad(0),math.rad(30),math.rad(40)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(math.rad(0),math.rad(-30),math.rad(-40)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(50)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(30)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
			end 
			RootPart.Anchored = false
			Attacking = false
		end
	end


	local ComboCont = 1
	local Attack = function()
		if Attacking == false then
			Attacking = true
			if ComboCont == 1 then
				for i = 0,10,1 do
					swait()
					bambam.Location = game.Players.LocalPlayer.Character["Right Arm"].Position
					game.Players.LocalPlayer.Character.HumanoidRootPart.Position = game.Players.LocalPlayer.Character["Right Arm"].Position
					neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(-30),math.rad(0),math.rad(80)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0.5,0,-1.2) * CFA(math.rad(0),math.rad(90),math.rad(90)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(20)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(10)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(30)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				end 

				for i = 0,15,1 do
					swait()
					bambam.Location = game.Players.LocalPlayer.Character["Right Arm"].Position
					game.Players.LocalPlayer.Character.HumanoidRootPart.Position = game.Players.LocalPlayer.Character["Right Arm"].Position
					neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,-3,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0.5,0,0) * CFA(math.rad(0),math.rad(-85),math.rad(90)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(20)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(40)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(30)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				end
				ComboCont = 2


			elseif ComboCont == 2 then
				for i = 0,10,1 do
					swait()
					bambam.Location = game.Players.LocalPlayer.Character["Left Arm"].Position
					game.Players.LocalPlayer.Character.HumanoidRootPart.Position = game.Players.LocalPlayer.Character["Left Arm"].Position
					neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(0),math.rad(90),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(-30),math.rad(0),math.rad(90)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-12)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-90)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(10)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(30)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				end 

				for i = 0,10,1 do
					swait()
					bambam.Location = game.Players.LocalPlayer.Character["Left Arm"].Position
					game.Players.LocalPlayer.Character.HumanoidRootPart.Position = game.Players.LocalPlayer.Character["Left Arm"].Position
					neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(0),math.rad(-90),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,-3,0) * CFA(math.rad(0),math.rad(0),math.rad(-90)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-12)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0.5) * CFA(math.rad(0),math.rad(90),math.rad(-90)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(10)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(30)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				end 
				ComboCont = 3
			elseif ComboCont == 3 then
				for i = 0,10,1 do
					swait()
					bambam.Location = game.Players.LocalPlayer.Character["Right Leg"].Position
					game.Players.LocalPlayer.Character.HumanoidRootPart.Position = game.Players.LocalPlayer.Character["Left Arm"].Position
					neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(10),math.rad(0),math.rad(-50)),LerpStyle(0.2,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-5)),LerpStyle(0.2,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(8)),LerpStyle(0.2,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(-50),math.rad(-98)),LerpStyle(0.2,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(20),math.rad(0)),LerpStyle(0.2,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				end 

				for i = 0,15,1 do
					swait()
					bambam.Location = game.Players.LocalPlayer.Character["Right Leg"].Position
					game.Players.LocalPlayer.Character.HumanoidRootPart.Position = game.Players.LocalPlayer.Character["Left Arm"].Position
					neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(0),math.rad(90),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,-3,0) * CFA(math.rad(-40),math.rad(0),math.rad(90)),LerpStyle(0.2,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-5)),LerpStyle(0.2,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(8)),LerpStyle(0.2,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(90),math.rad(-90+40)),LerpStyle(0.2,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(-90),math.rad(0)),LerpStyle(0.2,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				end 
				ComboCont = 1
			end
			Attacking = false
		end
	end
	local Mouse = game.Players.LocalPlayer:GetMouse()
	local B1Hold = false
	Mouse.Button1Down:Connect(function()
		B1Hold = true 
		while B1Hold == true do
			wait()
			Attack()
		end
	end)
	local Running = false
	Mouse.Button1Up:Connect(function()
		B1Hold = false
	end)
	Mouse.KeyDown:Connect(function(key)
		if key == "z" then
			SpinKick()
		else
			if key == "t" and Attacking == false then
				Attacking = true
				makesound("rbxassetid://6433451653",1,1,tors):Play()
				for i=0,100 do
					swait()
					neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad( -15 + math.rad(math.sin(time()*16)*15)),0,0),LerpStyle(0.2,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut))
					RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(-10 +  math.sin(time()*16)*10),math.rad(0),math.rad(0)),LerpStyle(0.1*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,0.4 + math.sin(time()*17)*0.4,0) * CFA(0,math.rad(90),math.rad(123)),LerpStyle(0.07*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(math.rad(10),0,math.rad(-90)),LerpStyle(0.07*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(-30 + math.sin(time()*17)*20),math.rad(-10 +  math.sin(time()*16)*10)),LerpStyle(0.1*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(10 +  math.sin(time()*16)*-10)),LerpStyle(0.1*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					TailWeld.C0 = TailWeld.C0:Lerp(TC0 * CFrame.Angles(math.rad(-20 + math.sin(-time()*3.83)*-20),math.rad(-math.sin(time()*3.83/2)*24),0),LerpStyle(0.1*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				end
				Attacking = false
			else
				if key == "r" and Attacking == false then
					Attacking = true
					while game.Players.LocalPlayer.Character.Humanoid.MoveDirection.Magnitude < 0.1 do
						swait()
						game.Players.LocalPlayer.Character.HumanoidRootPart.Position = tors.Position
						neck.C1 = neck.C1:Lerp(nek * CF(0,-0.4,0) * CFA(math.rad(-90),math.rad(-math.cos(time()*3)*30),0),LerpStyle(0.3,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut))
						RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,-2.5) * CFA(math.rad(78),math.rad(math.sin(time()*3)*12),math.rad(math.rad(math.sin(time()*3)*40))),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
						tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0.3,0.4 +0.4+math.sin(time()*3)*0.2,-0.4 -0.2+math.sin(time()*3)*0.2) * CFA(math.rad(-45)+math.rad(math.sin(time()*3)*12),math.rad(0),math.rad(180 - 10+math.cos(time()*3)*5)),LerpStyle(0.1*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
						tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(-0.3,0.4+0.4-math.sin(time()*3)*0.2,-0.4 -0.2+math.sin(time()*3)*0.2) * CFA(math.rad(-45)-math.rad(math.sin(time()*3)*12),math.rad(0),math.rad(-180 + 10 +math.cos(time()*3)*5)),LerpStyle(0.1*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
						tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(-math.sin(time()*3)*12),math.rad(math.sin(time()*3)*30),math.rad(-12 - 50 + math.cos(time()*3)*30)),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
						tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(-math.sin(time()*3)*12),math.rad(math.sin(time()*3)*30),math.rad(12 + 50 + math.cos(time()*3)*30)),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
						TailWeld.C0 = TailWeld.C0:Lerp(TC0 * CFrame.Angles(math.rad(0),0,math.rad(math.cos(time()*3)*40)),LerpStyle(0.1*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))

					end
					Attacking = false
				else if key == "f" then
						if Running == false then
							Running = true 
							Humanoid.WalkSpeed = 40
						else
							Running = false
							Humanoid.WalkSpeed = 20
						end
					elseif key == "x" and Attacking == false and Mouse.Target.Parent:FindFirstChildWhichIsA("Humanoid") ~= nil then
						Attacking = true
						Camera = workspace.CurrentCamera
						Camera.CameraType = "Scriptable"
						local Target = Mouse.Target.Parent
						for i = 0,200,1 do
							swait()
							Camera.CFrame = Camera.CFrame:Lerp(CFrame.new((head.CFrame * CFrame.new(0,0,-5)).Position,head.CFrame.Position),1)
							neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(20),math.rad(0),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(20),math.rad(0),math.rad(0)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,-0.5,0) * CFA(math.rad(-25),math.rad(0),math.rad(00)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,-0.5,0) * CFA(math.rad(-25),math.rad(0),math.rad(00)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(20+ -40)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-20+ -4)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						end

						for i = 0,20,1 do
							swait()
							Camera.CFrame = Camera.CFrame:Lerp(CFrame.new((head.CFrame * CFrame.new(0,0,-3)).Position,head.CFrame.Position),1)
							neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(20),math.rad(0),math.rad(0)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,-0.5,0) * CFA(math.rad(-40),math.rad(0),math.rad(00)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,-0.5,0) * CFA(math.rad(-40),math.rad(0),math.rad(00)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(20+ -40)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-20+ -4)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						end
						RootPart.CFrame = Target.HumanoidRootPart.CFrame * CFrame.new(0,0,-8)
						for i = 0,100,1 do
							swait()
							game.Players.LocalPlayer.Character.HumanoidRootPart.Position = Target.HumanoidRootPart.Position
							Camera.CFrame = Camera.CFrame:Lerp(CFrame.new((head.CFrame * CFrame.new(-3,0,0)).Position,Target.HumanoidRootPart.CFrame.Position),0.2)
							neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(20),math.rad(0),math.rad(0)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,-0.5,0) * CFA(math.rad(-80),math.rad(0),math.rad(-20)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,-0.5,0) * CFA(math.rad(-80),math.rad(0),math.rad(20)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(20+ -40)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-20+ -4)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						end
						Attacking = false
						Camera.CameraType = "Custom"
					end
				end
			end
		end
	end)
	local RLA = CFrame.new(0,0,0)

	local Anim = "Idle"



	Humanoid.WalkSpeed = 20
	Msgreq("FE Neko Anims V1.6","FE Neko Animations Loaded, have fun - Made by Creo",5,nil)
	while true do
		swait()
		hitfloor = rayCast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 0.5, 0)).lookVector, 4, CloneChar)
		local torvel = (game.Players.LocalPlayer.Character.Humanoid.MoveDirection * Vector3.new(1, 0, 1)).magnitude
		local velderp = RootPart.Velocity.y
		if RootPart.Velocity.y > 0 and hitfloor == nil then
			Anim = "Jumping"

		elseif RootPart.Velocity.y < 0 and hitfloor == nil then
			Anim = "Falling"
		elseif torvel < .5 and hitfloor ~= nil  then
			Anim = "Idle"
		elseif torvel > .5 and  hitfloor ~= nil  then
			Anim = "Walking"
		end
		local W1 = game.Players.LocalPlayer.Character.Humanoid.MoveDirection* RootPart.CFrame.LookVector
		local W2 = game.Players.LocalPlayer.Character.Humanoid.MoveDirection* RootPart.CFrame.RightVector
		WVA = W1.X+W1.Z
		RLV = W2.X+W2.Z


		if Attacking == false then
			game.Players.LocalPlayer.Character.HumanoidRootPart.Position = tors.Position
			if Anim == "Falling" then
				neck.C1 = neck.C1:Lerp(nek * CF(0,0,0.3) * CFA(math.rad(20),0,0),LerpStyle(0.4,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root *CF(0,0,0) * CFA(0,0,0),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,0,0) * CFA(math.rad(-40),0,math.rad(5)),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(math.rad(-40),0,math.rad(-5)),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0.4,0.8,0) * CFA(0,0,math.rad(10)),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0.4,0.5,0)  * CFA(0,0,math.rad(50)),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
			elseif Anim == "Jumping" then
				neck.C1 = neck.C1:Lerp(nek * CF(0,0,0.3) * CFA(math.rad(-20),0,0),LerpStyle(0.4,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root *CF(0,0,0) * CFA(0,0,0),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,0,0) * CFA(0,math.rad(-40),math.rad(-20)),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(0,math.rad(40),math.rad(20)),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0.4,0.8,0) * CFA(0,0,math.rad(-10)),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0.4,0.5,0)  * CFA(0,0,math.rad(-50)),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
			elseif Anim == "Idle" then
				neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(7+math.cos(time()*3.83)*-5 + (-6 + math.sin(time()*3.83)*6 )),math.rad(-24) + math.rad( math.sin((time()*3.83)/2)*10),math.rad(-math.cos((time()*3.83)/2)*13)),LerpStyle(0.2,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut))
				RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,math.cos((time()*3.83))/10) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(-0.1,math.cos((time()*3.83))/10,0) * CFA(math.rad(-5)- -math.sin((-time()*3.83))/8.7,math.rad(0),math.rad(5)+math.cos((-time()*3.83))/8.7),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0.1,math.cos((time()*3.83))/10,0) * CFA(math.rad(-5)- -math.sin((-time()*3.83))/8.7,math.rad(0),math.rad(-5)-math.cos((-time()*3.83))/8.7),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,-math.cos((time()*3.83))/8,0) * CFA(math.rad(-4),math.rad(-12),math.rad(8)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,-math.cos((time()*3.83))/8,0) * CFA(math.rad(-1),math.rad(7),math.rad(2)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				TailWeld.C0 = TailWeld.C0:Lerp(TC0 * CFrame.Angles(math.rad(-20 + math.sin(-time()*3.83)*-20),math.rad(-math.sin(time()*3.83/2)*24),0),LerpStyle(0.1*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
			elseif Anim == "Walking" and Running == false then
				RLA =  CFrame.new((math.sin((time()*8))/1)*0.5 *WVA,0.3*(1-WVA),(math.sin((time()*8))/1)*0.5 *RLV) * CFrame.Angles((-math.sin((time()*8))/1.5)*RLV,0,(math.sin((time()*8))/1.2)*WVA)
				LLA =  CFrame.new((math.sin((time()*8))/1)*0.5 *WVA,0.3*(1-WVA),(math.sin((time()*8))/1)*0.5 *RLV) * CFrame.Angles((-math.sin((time()*8))/1.5)*RLV,0,(math.sin((time()*8))/1.2)*WVA)
				neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(7),math.clamp(math.cos((time()*8))*0.2 + math.rad(-RootPart.RotVelocity.Y*8),math.rad(-85),math.rad(85)),math.rad(-RootPart.RotVelocity.Y*0.4)),LerpStyle(0.4,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root *CF(0,-math.sin((time()*8*2))/3.2,-math.sin((time()*8*2))/3) * CFA(math.rad( -15 + 10 + WVA*15) + -math.rad(math.sin(time() *(8*2))*10),math.clamp( math.rad(0) - -RootPart.RotVelocity.Y/50,math.rad(-20),math.rad(20)),math.cos((time()*8))*0.2),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(-math.sin((time()*8))/4.5,0,0) * CFA(math.rad(-5),-math.sin((time()*8))*0.1 + math.rad(RootPart.RotVelocity.Y*3),-math.sin((time()*8))*0.4),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(-math.sin((time()*8))/4.5,0,0) * CFA(math.rad(-5),-math.sin((time()*8))*0.1 + math.rad(RootPart.RotVelocity.Y*3),-math.sin((time()*8))*0.4),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,(math.cos((time()*8))/8),0) * RLA * CFA(0, (-math.sin((time()*8))*0.5)*WVA,math.rad( -15 + 10 + WVA*15) + -math.rad(math.sin(time() *(8*2))*10)),LerpStyle(0.2,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,(-math.cos((time()*8))/8),0) * LLA * CFA(0, (-math.sin((time()*8))*0.5)*WVA,-math.rad( -15 + 10 + WVA*15) + math.rad(math.sin(time() *(8*2))*10)),LerpStyle(0.2,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				TailWeld.C0 = TailWeld.C0:Lerp(TC0 * CFrame.Angles(math.rad(-30 + math.sin(-time()*8)*-20),0,-math.rad(-math.sin(time()*8/2)*20 + RLV*2)),LerpStyle(0.1*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
			elseif Anim == "Walking" and Running == true then
				RLA =  CFrame.new(0,(0.5 + math.cos(time()*15)*0.5)*WVA+ 0.2,(0.5 - math.cos(time()*15)*0.5)*RLV+ 0.2) * CFrame.Angles(0,-math.rad(math.sin(time()*15)*80)*RLV,math.rad(math.sin(time()*15)*80)*WVA)
				LLA =  CFrame.new(0,(0.5 + math.cos(time()*15)*0.5)*WVA- 0.2,(-0.5 + math.cos(time()*15)*0.5)*RLV- 0.2) * CFrame.Angles(0,-math.rad(math.sin(time()*15)*80)*RLV,math.rad(-math.sin(time()*15)*80)*WVA)
				RAA = CFrame.new(0,0.8 + math.sin(time()*15)*0.9*WVA,math.sin(time()*15)*0.9*RLV) * CFrame.Angles(0,math.rad(-math.cos(time()*15)*85)*RLV,math.rad(math.cos(time()*15)*85)*WVA)
				LAA = CFrame.new(0,0.8 + math.sin(time()*15)*0.9*WVA,math.sin(time()*15)*0.9*-RLV) * CFrame.Angles(0,math.rad(-math.cos(time()*15)*85)*RLV,math.rad(-math.cos(time()*15)*85)*WVA)
				neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(0,math.rad(-RootPart.RotVelocity.Y*5),0),LerpStyle(0.4,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root *CF((-1 - math.sin(time()*15)*2)*RLV,(-1 - math.sin(time()*15)*2)*WVA,-1 + 0.5 -math.sin(time()*15)*0.8) * CFA(math.rad(80 - math.cos(time()*15)*20),0,0),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0.6+ math.sin(time()*15)*1,0,-0.6)* RAA * CFA(math.rad(-10 - -math.cos(time()*15*2)*10),0,math.rad(80)),LerpStyle(0.6,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(-0.6+ -math.sin(time()*15)*1,0,-0.6) * LAA * CFA(math.rad(-10 - -math.cos(time()*15*2)*10),0,math.rad(-80)),LerpStyle(0.6,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0.4 + -math.cos(time()*15)*0.9,0,0) * RLA * CFA(0, 0,math.rad(50)),LerpStyle(0.6,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(-0.4+ math.cos(time()*15)*0.9,0,0) * LLA * CFA(0, 0,math.rad(-80)),LerpStyle(0.6,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				TailWeld.C0 = TailWeld.C0:Lerp(TC0 * CFrame.new(0,0.7,0.3) * CFrame.Angles(math.rad(-110 + math.sin(-time()*15)*-20),-math.rad(RLV*30),0),LerpStyle(0.1*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
			end
		end
	end
end)

UICorner_13.Parent = neko

reset.Name = "reset"
reset.Parent = AtlasHub
reset.BackgroundColor3 = Color3.fromRGB(27, 27, 27)
reset.Position = UDim2.new(0.375166893, 0, 0.655339777, 0)
reset.Size = UDim2.new(0, 125, 0, 50)
reset.Font = Enum.Font.Nunito
reset.Text = "Force reset"
reset.TextColor3 = Color3.fromRGB(255, 255, 255)
reset.TextScaled = true
reset.TextSize = 14.000
reset.TextWrapped = true

UICorner_14.Parent = reset

sam.Name = "sam"
sam.Parent = AtlasHub
sam.BackgroundColor3 = Color3.fromRGB(27, 27, 27)
sam.Position = UDim2.new(0.375166893, 0, 0.381067961, 0)
sam.Size = UDim2.new(0, 125, 0, 97)
sam.Font = Enum.Font.Nunito
sam.Text = "FE Jetstream"
sam.TextColor3 = Color3.fromRGB(255, 255, 255)
sam.TextScaled = true
sam.TextSize = 14.000
sam.TextWrapped = true
sam.MouseButton1Down:connect(function()
	loadstring(game:HttpGet(('https://raw.githubusercontent.com/kakabok1233453/asdasda/main/Red%20Samurai'),true))()
end)

UICorner_15.Parent = sam

TextLabel_2.Parent = AtlasHub
TextLabel_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_2.BackgroundTransparency = 1.000
TextLabel_2.BorderSizePixel = 0
TextLabel_2.Position = UDim2.new(0.0360480621, 0, 0.106796116, 0)
TextLabel_2.Size = UDim2.new(0, 233, 0, 58)
TextLabel_2.Font = Enum.Font.Nunito
TextLabel_2.Text = "Changelog:"
TextLabel_2.TextColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_2.TextScaled = true
TextLabel_2.TextSize = 14.000
TextLabel_2.TextWrapped = true

Frame_5.Parent = AtlasHub
Frame_5.BackgroundColor3 = Color3.fromRGB(9, 9, 9)
Frame_5.Position = UDim2.new(0.0493991971, 0, 0.247572809, 0)
Frame_5.Size = UDim2.new(0, 223, 0, 218)

UICorner_16.Parent = Frame_5

TextLabel_3.Parent = Frame_5
TextLabel_3.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_3.BackgroundTransparency = 1.000
TextLabel_3.BorderSizePixel = 0
TextLabel_3.Size = UDim2.new(0, 199, 0, 50)
TextLabel_3.Font = Enum.Font.Nunito
TextLabel_3.Text = "--Just opened to the public!"
TextLabel_3.TextColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_3.TextSize = 18.000
TextLabel_3.TextWrapped = true

UIListLayout.Parent = Frame_5
UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder

-- Scripts:

local function AMWKRFU_fake_script() -- ImageLabel.LocalScript 
	local script = Instance.new('LocalScript', ImageLabel)

	local Players = game:GetService("Players")
	
	local player = Players.LocalPlayer
	
	local userId = player.UserId
	local thumbType = Enum.ThumbnailType.HeadShot
	local thumbSize = Enum.ThumbnailSize.Size420x420
	local content, isReady = Players:GetUserThumbnailAsync(userId, thumbType, thumbSize)
	
	local imageLabel = script.Parent
	imageLabel.Image = content
	
end
coroutine.wrap(AMWKRFU_fake_script)()
local function CNWCTSV_fake_script() -- TextLabel.LocalScript 
	local script = Instance.new('LocalScript', TextLabel)

	local player = game.Players.LocalPlayer
	
	if player then
		script.Parent.Text = "" ..player.Name.. ""
	end
	
end
coroutine.wrap(CNWCTSV_fake_script)()
local function VOFKDH_fake_script() -- reset.LocalScript 
	local script = Instance.new('LocalScript', reset)

	script.Parent.MouseButton1Click:Connect(function()
		game.Players.LocalPlayer.Character.Humanoid.Health = 0
	end)
	
end
coroutine.wrap(VOFKDH_fake_script)()
